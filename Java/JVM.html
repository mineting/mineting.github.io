<!DOCTYPE html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-beta.63" />
    <meta name="theme" content="VuePress Theme Hope" />
    <link rel="icon" href="/favicon.ico"><link rel="icon" href="/assets/icon/chrome-mask-512.png" type="image/png" sizes="512x512"><link rel="icon" href="/assets/icon/chrome-mask-192.png" type="image/png" sizes="192x192"><link rel="icon" href="/assets/icon/chrome-512.png" type="image/png" sizes="512x512"><link rel="icon" href="/assets/icon/chrome-192.png" type="image/png" sizes="192x192"><link rel="manifest" href="/manifest.webmanifest" crossorigin="use-credentials"><meta name="theme-color" content="#46bd87"><link rel="apple-touch-icon" href="/assets/icon/apple-icon-152.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="msapplication-TileImage" content="/assets/icon/ms-icon-144.png"><meta name="msapplication-TileColor" content="#ffffff"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover"><title>JVM | MineTing</title><meta name="description" content="MineTing 的编程之路">
    <style>
      :root {
        --bg-color: #fff;
      }

      html[data-theme="dark"] {
        --bg-color: #1d1e1f;
      }

      html,
      body {
        background: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.documentElement.setAttribute("data-theme", "dark");
      }
    </script>
    <link rel="preload" href="/assets/style-a7f90041.css" as="style"><link rel="stylesheet" href="/assets/style-a7f90041.css">
    <link rel="modulepreload" href="/assets/app-50124fd5.js"><link rel="modulepreload" href="/assets/JVM.html-3407aec4.js"><link rel="modulepreload" href="/assets/JVM.html-3b995d07.js"><link rel="modulepreload" href="/assets/plugin-vue_export-helper-c27b6911.js">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="vp-skip-link sr-only">跳至主要內容</a><!--]--><div class="theme-container has-toc"><!--[--><header id="navbar" class="vp-navbar"><div class="vp-navbar-start"><button type="button" class="vp-toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!--[--><!----><!--]--><!--[--><a class="vp-link vp-brand" href="/"><img class="vp-nav-logo" src="/logo.svg" alt="MineTing"><!----><span class="vp-site-name hide-in-pad">MineTing</span></a><!--]--><!--[--><!----><!--]--></div><div class="vp-navbar-center"><!--[--><!----><!--]--><!--[--><!----><!--]--><!--[--><!----><!--]--></div><div class="vp-navbar-end"><!--[--><!----><!--]--><!--[--><!----><div class="nav-item vp-repo"><a class="vp-repo-link" href="https://github.com/vuepress-theme-hope/vuepress-theme-hope" target="_blank" rel="noopener noreferrer" aria-label="GitHub"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="github icon" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></svg></a></div><div class="nav-item hide-in-mobile"><button type="button" class="outlook-button" tabindex="-1" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" class="icon outlook-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="outlook icon"><path d="M224 800c0 9.6 3.2 44.8 6.4 54.4 6.4 48-48 76.8-48 76.8s80 41.6 147.2 0 134.4-134.4 38.4-195.2c-22.4-12.8-41.6-19.2-57.6-19.2C259.2 716.8 227.2 761.6 224 800zM560 675.2l-32 51.2c-51.2 51.2-83.2 32-83.2 32 25.6 67.2 0 112-12.8 128 25.6 6.4 51.2 9.6 80 9.6 54.4 0 102.4-9.6 150.4-32l0 0c3.2 0 3.2-3.2 3.2-3.2 22.4-16 12.8-35.2 6.4-44.8-9.6-12.8-12.8-25.6-12.8-41.6 0-54.4 60.8-99.2 137.6-99.2 6.4 0 12.8 0 22.4 0 12.8 0 38.4 9.6 48-25.6 0-3.2 0-3.2 3.2-6.4 0-3.2 3.2-6.4 3.2-6.4 6.4-16 6.4-16 6.4-19.2 9.6-35.2 16-73.6 16-115.2 0-105.6-41.6-198.4-108.8-268.8C704 396.8 560 675.2 560 675.2zM224 419.2c0-28.8 22.4-51.2 51.2-51.2 28.8 0 51.2 22.4 51.2 51.2 0 28.8-22.4 51.2-51.2 51.2C246.4 470.4 224 448 224 419.2zM320 284.8c0-22.4 19.2-41.6 41.6-41.6 22.4 0 41.6 19.2 41.6 41.6 0 22.4-19.2 41.6-41.6 41.6C339.2 326.4 320 307.2 320 284.8zM457.6 208c0-12.8 12.8-25.6 25.6-25.6 12.8 0 25.6 12.8 25.6 25.6 0 12.8-12.8 25.6-25.6 25.6C470.4 233.6 457.6 220.8 457.6 208zM128 505.6C128 592 153.6 672 201.6 736c28.8-60.8 112-60.8 124.8-60.8-16-51.2 16-99.2 16-99.2l316.8-422.4c-48-19.2-99.2-32-150.4-32C297.6 118.4 128 291.2 128 505.6zM764.8 86.4c-22.4 19.2-390.4 518.4-390.4 518.4-22.4 28.8-12.8 76.8 22.4 99.2l9.6 6.4c35.2 22.4 80 12.8 99.2-25.6 0 0 6.4-12.8 9.6-19.2 54.4-105.6 275.2-524.8 288-553.6 6.4-19.2-3.2-32-19.2-32C777.6 76.8 771.2 80 764.8 86.4z"></path></svg><div class="outlook-dropdown"><!----></div></button></div><!----><!--]--><!--[--><!----><!--]--><button type="button" class="vp-toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span><span class="vp-top"></span><span class="vp-middle"></span><span class="vp-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow start"></span></div><aside id="sidebar" class="vp-sidebar"><!--[--><!----><!--]--><ul class="vp-sidebar-links"><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable active" type="button"><!----><span class="vp-sidebar-title">Java</span><span class="vp-arrow down"></span></button><ul class="vp-sidebar-links"><li><!--[--><a class="vp-link nav-link vp-sidebar-link vp-sidebar-page" href="/Java/JavaSE.html"><!---->JavaSE<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a class="vp-link nav-link vp-sidebar-link vp-sidebar-page" href="/Java/JavaWeb.html"><!---->JavaWeb<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a class="vp-link nav-link vp-sidebar-link vp-sidebar-page" href="/Java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.html"><!---->数据结构与算法<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a class="vp-link nav-link vp-sidebar-link vp-sidebar-page" href="/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html"><!---->设计模式<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a class="vp-link nav-link active vp-sidebar-link vp-sidebar-page active" href="/Java/JVM.html"><!---->JVM<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/Java/JVM.html#jvm与java体系结构"><!---->JVM与Java体系结构<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/Java/JVM.html#java虚拟机概述"><!---->Java虚拟机概述<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/Java/JVM.html#java-及-jvm简介"><!---->Java 及 JVM简介<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/Java/JVM.html#java虚拟机的作用"><!---->Java虚拟机的作用<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/Java/JVM.html#java虚拟机的特点"><!---->Java虚拟机的特点<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/Java/JVM.html#jdk-的结构"><!---->JDK 的结构<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/Java/JVM.html#jvm整体结构-hotspot"><!---->JVM整体结构（HotSpot）<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/Java/JVM.html#类加载子系统"><!---->类加载子系统<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/Java/JVM.html#内存结构概述"><!---->内存结构概述<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/Java/JVM.html#类加载器以及类的加载过程"><!---->类加载器以及类的加载过程<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/Java/JVM.html#classloader-类加载器"><!---->ClassLoader：类加载器<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/Java/JVM.html#类的加载过程-loading"><!---->类的加载过程：Loading<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/Java/JVM.html#类的链接过程-linking"><!---->类的链接过程：Linking<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/Java/JVM.html#类的初始化过程-initialization"><!---->类的初始化过程：Initialization<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/Java/JVM.html#几种类加载器的说明"><!---->几种类加载器的说明<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/Java/JVM.html#类加载器的分类"><!---->类加载器的分类<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/Java/JVM.html#双亲委派机制"><!---->双亲委派机制<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/Java/JVM.html#运行时数据区及概述及线程"><!---->运行时数据区及概述及线程<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/Java/JVM.html#运行时数据区结构概述"><!---->运行时数据区结构概述<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/Java/JVM.html#jvm中的线程说明"><!---->JVM中的线程说明<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/Java/JVM.html#程序计数器"><!---->程序计数器<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/Java/JVM.html#虚拟机栈"><!---->虚拟机栈<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/Java/JVM.html#虚拟机栈的概述"><!---->虚拟机栈的概述<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/Java/JVM.html#栈的存储结构和运行原理"><!---->栈的存储结构和运行原理<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/Java/JVM.html#局部变量表"><!---->局部变量表<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/Java/JVM.html#操作数栈"><!---->操作数栈<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/Java/JVM.html#栈顶缓存技术"><!---->栈顶缓存技术<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/Java/JVM.html#动态链接"><!---->动态链接<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/Java/JVM.html#方法的调用"><!---->方法的调用<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/Java/JVM.html#方法返回地址"><!---->方法返回地址<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/Java/JVM.html#一些附加信息"><!---->一些附加信息<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/Java/JVM.html#相关5个问题"><!---->相关5个问题<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/Java/JVM.html#本地方法接口-java-method-interface"><!---->本地方法接口（Java Method Interface）<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/Java/JVM.html#本地方法栈-native-method-stack"><!---->本地方法栈（Native Method Stack）<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/Java/JVM.html#堆"><!---->堆<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/Java/JVM.html#堆的核心描述"><!---->堆的核心描述<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/Java/JVM.html#堆的核心描述-内存细分"><!---->堆的核心描述：内存细分<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/Java/JVM.html#设置堆内存的大小与oom"><!---->设置堆内存的大小与OOM<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/Java/JVM.html#年轻代与老年代"><!---->年轻代与老年代<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/Java/JVM.html#图像对象的分配过程"><!---->图像对象的分配过程<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/Java/JVM.html#minor-gc、major-gc、full-gc"><!---->Minor GC、Major GC、Full GC<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/Java/JVM.html#对象分配过程-tlab"><!---->对象分配过程：TLAB<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/Java/JVM.html#垃圾回收概述"><!---->垃圾回收概述<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/Java/JVM.html#什么是垃圾"><!---->什么是垃圾<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/Java/JVM.html#为什么需要gc"><!---->为什么需要GC<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/Java/JVM.html#早期垃圾回收"><!---->早期垃圾回收<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/Java/JVM.html#java-自动内存管理介绍"><!---->Java 自动内存管理介绍<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/Java/JVM.html#垃圾回收算法"><!---->垃圾回收算法<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/Java/JVM.html#标记阶段-引用计数算法"><!---->标记阶段：引用计数算法<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/Java/JVM.html#标记阶段-可达性分析算法"><!---->标记阶段：可达性分析算法<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/Java/JVM.html#对象的-finalization-机制"><!---->对象的 finalization 机制<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/Java/JVM.html#mat-与-jprofiler-的-gc-rosts-溯源"><!---->MAT 与 jprofiler 的 GC ROSTS 溯源<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/Java/JVM.html#清除阶段-标记-清除算法"><!---->清除阶段：标记-清除算法<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/Java/JVM.html#清除阶段-复制算法"><!---->清除阶段：复制算法<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/Java/JVM.html#清除阶段-标记-压缩算法"><!---->清除阶段：标记-压缩算法<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/Java/JVM.html#小结"><!---->小结<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/Java/JVM.html#分代收集算法"><!---->分代收集算法<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/Java/JVM.html#增量收集算法、分区算法"><!---->增量收集算法、分区算法<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/Java/JVM.html#垃圾回收概念"><!---->垃圾回收概念<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/Java/JVM.html#垃圾回收器"><!---->垃圾回收器<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul><!--]--></li><li><!--[--><a class="vp-link nav-link vp-sidebar-link vp-sidebar-page" href="/Java/Http.html"><!---->Http<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a class="vp-link nav-link vp-sidebar-link vp-sidebar-page" href="/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.html"><!---->多线程与并发编程<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a class="vp-link nav-link vp-sidebar-link vp-sidebar-page" href="/Java/Netty.html"><!---->Netty<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a class="vp-link nav-link vp-sidebar-link vp-sidebar-page" href="/Java/Effective%20Java.html"><!---->EffectiveJava<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a class="vp-link nav-link vp-sidebar-link vp-sidebar-page" href="/Java/Maven-Gradle.html"><!---->Maven-Gradle<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a class="vp-link nav-link vp-sidebar-link vp-sidebar-page" href="/Java/Git-Svn.html"><!---->Git-Svn<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a class="vp-link nav-link vp-sidebar-link vp-sidebar-page" href="/Java/Mybatis.html"><!---->Mybatis<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a class="vp-link nav-link vp-sidebar-link vp-sidebar-page" href="/Java/MybatisPlus.html"><!---->MybatisPlus<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a class="vp-link nav-link vp-sidebar-link vp-sidebar-page" href="/Java/Spring.html"><!---->Spring<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a class="vp-link nav-link vp-sidebar-link vp-sidebar-page" href="/Java/SpringMVC.html"><!---->SpringMVC<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a class="vp-link nav-link vp-sidebar-link vp-sidebar-page" href="/Java/SpringSecurity.html"><!---->SpringSecurity<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a class="vp-link nav-link vp-sidebar-link vp-sidebar-page" href="/Java/SpringBoot2.html"><!---->SpringBoot<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a class="vp-link nav-link vp-sidebar-link vp-sidebar-page" href="/Java/SpringCloud.html"><!---->SpringCloud<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a class="vp-link nav-link vp-sidebar-link vp-sidebar-page" href="/Java/Dubbo.html"><!---->Dubbo<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a class="vp-link nav-link vp-sidebar-link vp-sidebar-page" href="/Java/ServerLess.html"><!---->ServerLess<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a class="vp-link nav-link vp-sidebar-link vp-sidebar-page" href="/Java/Nginx.html"><!---->Nginx<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a class="vp-link nav-link vp-sidebar-link vp-sidebar-page" href="/Java/Zookeeper.html"><!---->Zookeeper<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a class="vp-link nav-link vp-sidebar-link vp-sidebar-page" href="/Java/ActiveMQ.html"><!---->ActiveMQ<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a class="vp-link nav-link vp-sidebar-link vp-sidebar-page" href="/Java/RabbitMQ.html"><!---->RabbitMQ<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a class="vp-link nav-link vp-sidebar-link vp-sidebar-page" href="/Java/Kafka.html"><!---->Kafka<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a class="vp-link nav-link vp-sidebar-link vp-sidebar-page" href="/Java/RocketMQ.html"><!---->RocketMQ<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a class="vp-link nav-link vp-sidebar-link vp-sidebar-page" href="/Java/Elasticsearch.html"><!---->Elasticsearch<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a class="vp-link nav-link vp-sidebar-link vp-sidebar-page" href="/Java/%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF%E5%AE%9E%E7%8E%B0.html"><!---->常见场景实现<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a class="vp-link nav-link vp-sidebar-link vp-sidebar-page" href="/Java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.html"><!---->计算机网络<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a class="vp-link nav-link vp-sidebar-link vp-sidebar-page" href="/Java/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html"><!---->操作系统<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a class="vp-link nav-link vp-sidebar-link vp-sidebar-page" href="/Java/interview.html"><!---->Interview<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li></ul></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><!----><span class="vp-sidebar-title">Web</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><!----><span class="vp-sidebar-title">Linux</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><!----><span class="vp-sidebar-title">DataBase</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><!----><span class="vp-sidebar-title">Python</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><!----><span class="vp-sidebar-title">BigData</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><!----><span class="vp-sidebar-title">C++</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><!----><span class="vp-sidebar-title">其他</span><span class="vp-arrow end"></span></button><!----></section></li></ul><!--[--><!----><!--]--></aside><!--[--><main id="main-content" class="vp-page"><!--[--><!----><!----><nav class="vp-breadcrumb disable"></nav><div class="vp-page-title"><h1><!---->JVM</h1><div class="page-info"><span class="page-author-info" aria-label="作者🖊" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="author icon"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><span class="page-author-item">MineTing</span></span><span property="author" content="MineTing"></span></span><!----><span class="page-date-info" aria-label="写作日期📅" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span><!----></span><meta property="datePublished" content="2023-03-01T00:00:00.000Z"></span><!----><span class="page-reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 75 分钟</span><meta property="timeRequired" content="PT75M"></span><!----><!----></div><hr></div><div class="toc-place-holder"><aside id="toc"><!--[--><!----><!--]--><div class="toc-header">此页内容<button type="button" class="print-button" title="打印"><svg xmlns="http://www.w3.org/2000/svg" class="icon print-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="print icon"><path d="M819.2 364.8h-44.8V128c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v236.8h-44.8C145.067 364.8 96 413.867 96 473.6v192c0 59.733 49.067 108.8 108.8 108.8h44.8V896c0 17.067 14.933 32 32 32h460.8c17.067 0 32-14.933 32-32V774.4h44.8c59.733 0 108.8-49.067 108.8-108.8v-192c0-59.733-49.067-108.8-108.8-108.8zM313.6 160h396.8v204.8H313.6V160zm396.8 704H313.6V620.8h396.8V864zM864 665.6c0 25.6-19.2 44.8-44.8 44.8h-44.8V588.8c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v121.6h-44.8c-25.6 0-44.8-19.2-44.8-44.8v-192c0-25.6 19.2-44.8 44.8-44.8h614.4c25.6 0 44.8 19.2 44.8 44.8v192z"></path></svg></button></div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level2" href="/#jvm与java体系结构">JVM与Java体系结构</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#java虚拟机概述">Java虚拟机概述</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#java-及-jvm简介">Java 及 JVM简介</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#java虚拟机的作用">Java虚拟机的作用</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#java虚拟机的特点">Java虚拟机的特点</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#jdk-的结构">JDK 的结构</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#jvm整体结构-hotspot">JVM整体结构（HotSpot）</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2" href="/#类加载子系统">类加载子系统</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#内存结构概述">内存结构概述</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#类加载器以及类的加载过程">类加载器以及类的加载过程</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#classloader-类加载器">ClassLoader：类加载器</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#类的加载过程-loading">类的加载过程：Loading</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#类的链接过程-linking">类的链接过程：Linking</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#类的初始化过程-initialization">类的初始化过程：Initialization</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#几种类加载器的说明">几种类加载器的说明</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#类加载器的分类">类加载器的分类</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#双亲委派机制">双亲委派机制</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2" href="/#运行时数据区及概述及线程">运行时数据区及概述及线程</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#运行时数据区结构概述">运行时数据区结构概述</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#jvm中的线程说明">JVM中的线程说明</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#程序计数器">程序计数器</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2" href="/#虚拟机栈">虚拟机栈</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#虚拟机栈的概述">虚拟机栈的概述</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#栈的存储结构和运行原理">栈的存储结构和运行原理</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#局部变量表">局部变量表</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#操作数栈">操作数栈</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#栈顶缓存技术">栈顶缓存技术</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#动态链接">动态链接</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#方法的调用">方法的调用</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#方法返回地址">方法返回地址</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#一些附加信息">一些附加信息</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#相关5个问题">相关5个问题</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2" href="/#本地方法接口-java-method-interface">本地方法接口（Java Method Interface）</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2" href="/#本地方法栈-native-method-stack">本地方法栈（Native Method Stack）</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2" href="/#堆">堆</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#堆的核心描述">堆的核心描述</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#堆的核心描述-内存细分">堆的核心描述：内存细分</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#设置堆内存的大小与oom">设置堆内存的大小与OOM</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#年轻代与老年代">年轻代与老年代</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#图像对象的分配过程">图像对象的分配过程</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#minor-gc、major-gc、full-gc">Minor GC、Major GC、Full GC</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#对象分配过程-tlab">对象分配过程：TLAB</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2" href="/#垃圾回收概述">垃圾回收概述</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#什么是垃圾">什么是垃圾</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#为什么需要gc">为什么需要GC</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#早期垃圾回收">早期垃圾回收</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#java-自动内存管理介绍">Java 自动内存管理介绍</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2" href="/#垃圾回收算法">垃圾回收算法</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#标记阶段-引用计数算法">标记阶段：引用计数算法</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#标记阶段-可达性分析算法">标记阶段：可达性分析算法</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#对象的-finalization-机制">对象的 finalization 机制</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#mat-与-jprofiler-的-gc-rosts-溯源">MAT 与 jprofiler 的 GC ROSTS 溯源</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#清除阶段-标记-清除算法">清除阶段：标记-清除算法</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#清除阶段-复制算法">清除阶段：复制算法</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#清除阶段-标记-压缩算法">清除阶段：标记-压缩算法</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#小结">小结</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#分代收集算法">分代收集算法</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#增量收集算法、分区算法">增量收集算法、分区算法</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2" href="/#垃圾回收概念">垃圾回收概念</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2" href="/#垃圾回收器">垃圾回收器</a></li><!----><!--]--></ul><div class="toc-marker" style="top:-1.7rem;"></div></div><!--[--><!----><!--]--></aside></div><!----><div class="theme-hope-content"><div align="center"><!----></div><blockquote><p>【Refer】</p><p>宋红康 JVM</p></blockquote><h1 id="上篇-java内存与垃圾回收" tabindex="-1"><a class="header-anchor" href="#上篇-java内存与垃圾回收" aria-hidden="true">#</a> 上篇：Java内存与垃圾回收</h1><h2 id="jvm与java体系结构" tabindex="-1"><a class="header-anchor" href="#jvm与java体系结构" aria-hidden="true">#</a> JVM与Java体系结构</h2><h3 id="java虚拟机概述" tabindex="-1"><a class="header-anchor" href="#java虚拟机概述" aria-hidden="true">#</a> Java虚拟机概述</h3><h4 id="为什么要学-jvm" tabindex="-1"><a class="header-anchor" href="#为什么要学-jvm" aria-hidden="true">#</a> 为什么要学 JVM？</h4><ol><li><p>如何让系统更快， 如何避免系统出现性能瓶颈。单纯的依靠物理机不足以解决问题，分析系统性能、调优系统瓶颈离不了对 JVM 中内存、垃圾回收、字节码指令、性能监控工具、调优参数的熟练掌握。</p></li><li><p>JVM 是 Java 生态的核心价值的体现，垃圾回收算法、JIT、底层原理值得每个程序员去探索。同时，JVM 作为跨语言的平台，对于深入理解 Scala、Kotlin、JavaScript、Jython、Groovy 也很有帮助。</p></li><li><p>Java默认使用HotSpot作为虚拟机</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>C:<span class="token punctuation">\</span>Users<span class="token punctuation">\</span><span class="token number">1696</span><span class="token operator"><span class="token file-descriptor important">8</span>&gt;</span>java <span class="token parameter variable">-version</span>
<span class="token function">java</span> version <span class="token string">&quot;1.8.0_181&quot;</span>
Java<span class="token punctuation">(</span>TM<span class="token punctuation">)</span> SE Runtime Environment <span class="token punctuation">(</span>build <span class="token number">1.8</span>.0_181-b13<span class="token punctuation">)</span>
Java HotSpot<span class="token punctuation">(</span>TM<span class="token punctuation">)</span> <span class="token number">64</span>-Bit Server VM <span class="token punctuation">(</span>build <span class="token number">25.181</span>-b13, mixed mode<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ol><h4 id="java-跨平台语言的体现" tabindex="-1"><a class="header-anchor" href="#java-跨平台语言的体现" aria-hidden="true">#</a> Java 跨平台语言的体现</h4><ol><li>字节码文件可以由不同的编程语言提供（相应的编译器）</li><li>Java 虚拟机可以运行非 Java 语言编写的程序，只关心字节码文件。</li><li>JVM 最强大的虚拟机，解释运行字节码文件。</li><li>多语言混合编程运行的趋势。</li></ol><figure><img src="/assets/Java跨平台语言的体现-2b11845b.jpg" alt="Java跨平台语言的体现" tabindex="0" loading="lazy"><figcaption>Java跨平台语言的体现</figcaption></figure><h3 id="java-及-jvm简介" tabindex="-1"><a class="header-anchor" href="#java-及-jvm简介" aria-hidden="true">#</a> Java 及 JVM简介</h3><h4 id="java发展的重大事件" tabindex="-1"><a class="header-anchor" href="#java发展的重大事件" aria-hidden="true">#</a> Java发展的重大事件</h4><ul><li>1990年，在Sun计算机公司中，由Patrick Naughton、MikeSheridan及James Gosling 领导的小组Green Team，开发出的新的程序语言，命名为0ak，后期命名为Java。</li><li>1995年， Sun正式发布Java和HotJava产品，Java首次公开亮相。</li><li>1996年1月23日Sun Microsystems发布了JDK 1.0。</li><li>1998年，JDK 1.2版本发布。同时，Sun发布了JSP/Servlet、EJB规范，以及将Java分成了J2EE、J2SE和J2ME。这表明了Java开始向企业、桌面应用和移动设备应用3大领域挺进。</li><li>2000年，JDK 1.3发布，Java HotSpot Virtual Machine正式发布，成为Java的默认虛拟机。</li><li>2002年，JDK 1.4发布，古老的Classic虚拟机退出历史舞台。</li><li>2003年年底，Java平台的Scala正式发布，同年Groovy也加入了Java阵营。</li><li>2004年，JDK 1.5发布。同时JDK 1.5改名为JavaSE 5.0。</li><li>2006年，JDK 6发布。同年，Java开源并建立了OpenJDK。顺理成章，Hotspot虚拟机也成为了OpenJDK中的默认虛拟机。</li><li>2007年，Java平台迎来了新伙伴Clojure。</li><li>2008年，Oracle 收购了BEA， 得到了JRockit 虚拟机。</li><li>2009年，Twitter宣布把后台大部分程序从Ruby迁移到scala，这是Java平台的又一次大规模应用。</li><li>2010年，Oracle收购了Sun，获得Java商标和最具价值的HotSpot虚拟机。此时，Oracle拥有市场占用率最高的两款虚拟机HotSpot和JRockit，并计划在未来对它们进行整合： HotRockit. JCP组织管理： Java语言</li><li>2011年，JDK7发布。在JDK 1. 7u4中，正式启用了新的垃圾回收器G1。</li><li>2017年，JDK9发布。将G1设置为默认GC，替代CMS，同年，IBM的J9开源，形成了现在的Open J9社区。</li><li>2018年，Android的Java侵权案判决，Google赔 偿Oracle计88亿美元，同年，Oracle宣告JavaEE成为历史名词，JDBC、 JMS、Servlet赠予Eclipse基金会，同年，JDK11发布，LTS版本的JDK，发布革命性的ZGC，调整JDK授权许可。</li><li>2019年，JDK12发布，加入RedHat领导开发的Shenandoah GC。</li></ul><p>三大主流虚拟机：Hotspot、Jrockit、J9</p><h4 id="虚拟机" tabindex="-1"><a class="header-anchor" href="#虚拟机" aria-hidden="true">#</a> 虚拟机</h4><ol><li><p>Virtual Machine，是一台虚拟的计算机，是一款软件，用来执行一系列虚拟的计算机指令，大体可以分为：系统虚拟机和程序虚拟机。</p></li><li><p>Virtual Box 和 VMware 是系统虚拟机，是对物理计算机的仿真，提供了一个可运行操作系统的软件平台。</p></li><li><p>程序虚拟机的典型代表是 Java 虚拟机，它专门执行单个计算机程序而设计，在 Java 虚拟机中执行的指令我们称为 Java字节码指令。</p></li><li><p>无论是系统虚拟机还是程序虚拟机，在上面运行的软件都被限制在虚拟机提供的资源中。</p></li></ol><h4 id="java虚拟机" tabindex="-1"><a class="header-anchor" href="#java虚拟机" aria-hidden="true">#</a> Java虚拟机</h4><ol><li><p>Java 虚拟机是一台执行 Java 字节码的虚拟计算机，它拥有独立的运行机制，机器运行的字节码未必是由 Java编写的。</p></li><li><p>JVM 平台的各种语言可以共享 Java 虚拟机带来的跨平台性、优秀的垃圾回收机制，以及可靠的即时编译器。</p></li><li><p>Java技术的核心就是 Java虚拟机（Java Virtual VMware），因为所有的 Java 程序都运行在 Java 虚拟机内部。</p></li></ol><h3 id="java虚拟机的作用" tabindex="-1"><a class="header-anchor" href="#java虚拟机的作用" aria-hidden="true">#</a> Java虚拟机的作用</h3><ol><li>Java 虚拟机就是二进制字节码的运行环境，负责装载字节码到其内部，解释/编译为对应平台上的机器指令执行。</li><li>每一条 Java 指令，Java 虚拟机规范中都有详细定义，如取操作数，处理操作数，处理结果放在哪里。</li></ol><h3 id="java虚拟机的特点" tabindex="-1"><a class="header-anchor" href="#java虚拟机的特点" aria-hidden="true">#</a> Java虚拟机的特点</h3><ol><li><mark>跨平台，一次编译，到处运行</mark></li><li><mark>自动内存管理</mark></li><li><mark>自动垃圾回收机制</mark></li><li><mark>即时编译</mark></li></ol><h3 id="jdk-的结构" tabindex="-1"><a class="header-anchor" href="#jdk-的结构" aria-hidden="true">#</a> JDK 的结构</h3><p>文档：<a href="https://docs.oracle.com/javase/8/docs/index.html" target="_blank" rel="noopener noreferrer">https://docs.oracle.com/javase/8/docs/index.html<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><img src="/assets/JDK结构-d22a4cf1.jpg" style="zoom:80%;"><h3 id="jvm整体结构-hotspot" tabindex="-1"><a class="header-anchor" href="#jvm整体结构-hotspot" aria-hidden="true">#</a> JVM整体结构（HotSpot）</h3><p>​ HotSpot VM是目前上性能最高的虚拟机代表之一，<strong>它采用的是解释器与即时编译器并存的架构。</strong></p><h2 id="类加载子系统" tabindex="-1"><a class="header-anchor" href="#类加载子系统" aria-hidden="true">#</a> 类加载子系统</h2><h3 id="内存结构概述" tabindex="-1"><a class="header-anchor" href="#内存结构概述" aria-hidden="true">#</a> 内存结构概述</h3><p>​ 虚拟机最重要的是两个部分：类加载器和执行引擎</p><p><strong>简单版：</strong></p><figure><img src="/assets/内存结构概述简单版-e24decdf.png" alt="内存结构概述简单版.png" tabindex="0" loading="lazy"><figcaption>内存结构概述简单版.png</figcaption></figure><p><strong>详细版：</strong></p><figure><img src="/assets/内存结构概述详细版-18c97e06.png" alt="内存结构概述详细版.png" tabindex="0" loading="lazy"><figcaption>内存结构概述详细版.png</figcaption></figure><p>说明：</p><ul><li><p>每个线程都有一份PC寄存器</p></li><li><p>对于虚拟机栈：包含很多的栈帧，栈帧的结构如下：</p><ul><li>LV：局部变量表</li><li>OS：操作数栈</li><li>DL：动态链接库</li><li>RA：方法返回地址</li></ul></li><li><p>本地方法栈：由本地方法调用采用本地方法栈</p></li><li><p>堆区：共享区域，存储对象</p></li><li><p>方法区：存储类的信息，常量池，方法信息等，方法区是 HotSpot 特有的，Jdk1.7之前方法区也称作永久代，JDK1.8之后称为元空间。</p></li></ul><figure><img src="/assets/内存结构概述中文详细版-7b485edb.png" alt="内存结构概述中文详细版.png" tabindex="0" loading="lazy"><figcaption>内存结构概述中文详细版.png</figcaption></figure><h3 id="类加载器以及类的加载过程" tabindex="-1"><a class="header-anchor" href="#类加载器以及类的加载过程" aria-hidden="true">#</a> 类加载器以及类的加载过程</h3><figure><img src="/assets/类的加载过程-ed594319.png" alt="类的加载过程.png" tabindex="0" loading="lazy"><figcaption>类的加载过程.png</figcaption></figure><ul><li><p>类加载器子系统负责从文件系统或网络中加载Class文件，Class文件在文件开头由特定的文件标识。</p></li><li><p>ClassLoader只负责class文件的加载，至于是否可以运行，则由 Execution Engine 决定。</p></li><li><p>加载的类的信息存放于方法区的内存空间，除了类的信息，方法区还会存放运行时常量池的信息，可能还包括字符串字面量和数字常量，（这部分常量信息是Class文件中常量池部分的内存映射）。</p></li></ul><h3 id="classloader-类加载器" tabindex="-1"><a class="header-anchor" href="#classloader-类加载器" aria-hidden="true">#</a> ClassLoader：类加载器</h3><p>​ Class file 存在于磁盘中，通过类加载器加载到 JVM 中，根据这个文件实例化出 n 个一模一样的实例，Class file加载到 JVM中，被称为DNA元数据模板，放在方法区，该过程需要 ClassLoader 来完成。</p><p>class 文件可以通过 getClassLoader() 获得类加载器。</p><h3 id="类的加载过程-loading" tabindex="-1"><a class="header-anchor" href="#类的加载过程-loading" aria-hidden="true">#</a> 类的加载过程：Loading</h3><figure><img src="/assets/类的加载过程简单版-4731e9be.png" alt="类的加载过程简单版.png" tabindex="0" loading="lazy"><figcaption>类的加载过程简单版.png</figcaption></figure><p>过程：</p><ul><li><p>通过类的全限定名从磁盘上获取定义此类的二进制流</p></li><li><p>将这个字节流所代表的静态存储结构转化为方法区的运行时的数据结构</p></li><li><p><strong>在内存中生成一个代表这个类的java.lang.Class对象</strong>，作为方法区这个类的各种数据访问入口</p></li></ul><p>加载 .class 的方式：</p><ul><li>从本地系统中加载</li><li>通过网络系统获取，典型的场景：Web Applet</li><li>从Zip压缩包中读取，称为jar、war格式的基础</li><li>运行时计算生成，使用最多的是动态代理</li><li>有其他文件生成，典型：Jsp</li><li>从专有的数据库中提取，少见</li><li>从加密文件中获取，典型的防Class文件被反编译的保护措施</li></ul><h3 id="类的链接过程-linking" tabindex="-1"><a class="header-anchor" href="#类的链接过程-linking" aria-hidden="true">#</a> 类的链接过程：Linking</h3><h4 id="验证-verify" tabindex="-1"><a class="header-anchor" href="#验证-verify" aria-hidden="true">#</a> 验证：Verify</h4><p>​ 目的在于确保class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。主要包括四种验证，<strong>文件格式验证，元数据验证，字节码验证，符号引用验证</strong>。</p><p>class文件以 &quot;CAFE&quot; 开始：</p><h4 id="准备-prepare" tabindex="-1"><a class="header-anchor" href="#准备-prepare" aria-hidden="true">#</a> 准备：Prepare</h4><p><strong>1.</strong> <strong>为类变量分配内存并且设置该类变量的默认初始值，即零值</strong></p><p><strong>2.</strong> <strong>这里不包含用 final 修饰的 static，因为 final 在编译的时候就会分配了，准备阶段会显式初始化</strong></p><p><strong>3.</strong> <strong>这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中</strong></p><h4 id="解析-resolve" tabindex="-1"><a class="header-anchor" href="#解析-resolve" aria-hidden="true">#</a> 解析：Resolve</h4><ol><li><p>将常量池内的符号引用转换为直接引用的过程。</p></li><li><p>事实上，解析操作往往会伴随着 JVM 在执行完初始化之后再执行。</p></li><li><p>符号引用就是一组符号来描述所引用的目标。<strong>符号引用</strong>的字面量形式明确定义在《java虚拟机规范》的class文件格式中。<strong>直接引用</strong>就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</p></li><li><p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的 CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info等。</p></li></ol><h3 id="类的初始化过程-initialization" tabindex="-1"><a class="header-anchor" href="#类的初始化过程-initialization" aria-hidden="true">#</a> 类的初始化过程：Initialization</h3><ol><li><p>初始化阶段就是<strong>执行类构造器方法&lt;clinit&gt;()的过程</strong>。</p></li><li><p>此方法不需定义，是javac编译器自动收集类中的<strong>所有类变量的赋值动作和静态代码块</strong>中的语句合并而来。</p></li><li><p>构造器方法中指令按语句在源文件中出现的顺序执行。</p></li><li><p>&lt;clinit&gt;() 不同于类的构造器。(关联：构造器是虚拟机视角下的&lt;init&gt;() )若该类具有父类，JVM会保证子类的&lt;clinit&gt;() 执行前，父类的&lt;clinit&gt; () 已经执行完毕。</p></li><li><p>虚拟机必须保证一个类的&lt;clinit&gt; () 方法在多线程下被同步加锁。</p></li><li><p>如果没有类变量，不会生成&lt;clinit&gt;方法，构造器对应&lt;init&gt;方法。</p></li><li><p>JDK8的元空间使用本地内存，类的加载被直接内存缓存，只加载一次，调用一次&lt;clinit&gt;方法。</p></li></ol><h3 id="几种类加载器的说明" tabindex="-1"><a class="header-anchor" href="#几种类加载器的说明" aria-hidden="true">#</a> 几种类加载器的说明</h3><p>​ JVM 支持两种类型的类加载器，分别为引导类加载器（BootstrapClassLoader）和自定义类加载器（User-Defined ClassLoader)。从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java虚拟机规范却没有这么定义，而是将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器。无论类加载器的类型如何划分，在程序中我们最常见的类加载器始终只有3个，如下所示：</p><ul><li>BootStrap ClassLoader</li><li>Extension ClassLoader</li><li>System ClassLoader</li><li>UserDefine ClassLoader</li></ul><p>这四者的关系是包含关系，而非继承或上下层等，从另一角度说：引导类加载器不是Java写的，无法获取对象。</p><h3 id="类加载器的分类" tabindex="-1"><a class="header-anchor" href="#类加载器的分类" aria-hidden="true">#</a> 类加载器的分类</h3><h4 id="启动-引导类加载器-bootstrap-classloader" tabindex="-1"><a class="header-anchor" href="#启动-引导类加载器-bootstrap-classloader" aria-hidden="true">#</a> 启动/引导类加载器 (Bootstrap ClassLoader)</h4><ol><li><p>这个类加载使用C/C++语言实现的，嵌套在 JVM 内部。</p></li><li><p>它用来加载 Java 的核心库（JAVA_HOME/jre/lib/rt. jar、resources.jar 或 sun.boot.class.path 路径下的内容），用于提供 JVM 自身需要的类。</p></li><li><p>并不继承自 java.lang.ClassLoader，没有父加载器。</p></li><li><p>引导类加载器加载扩展类和应用程序类加载器，并指定为他们的父类加载器。</p></li><li><p>出于安全考虑，Bootstrap启动类加载器只加载包名为java、 javax、sun等开头的类。</p></li></ol><h4 id="扩展类加载器-extension-classloader" tabindex="-1"><a class="header-anchor" href="#扩展类加载器-extension-classloader" aria-hidden="true">#</a> 扩展类加载器(Extension ClassLoader)</h4><ol><li><p>Java语言编写，由sun.misc.Launcher$ExtClassLoader实现。</p></li><li><p>派生于classLoader类，父类加载器为启动类加载器</p></li><li><p>从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/lib/ext子目录（扩展目录）下加载类库。</p></li><li><p>如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。</p></li></ol><h4 id="用户自定义类加载器" tabindex="-1"><a class="header-anchor" href="#用户自定义类加载器" aria-hidden="true">#</a> 用户自定义类加载器</h4><p>​ 在 Java 的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方式。</p><p>为什么要自定义类加载器?</p><ol><li><p>隔离加载类（避免多个框架定义相同的类）</p></li><li><p>修改类加载的方式</p></li><li><p>扩展加载源</p></li><li><p>防止源码泄漏（对字节码进行加密和解密操作）</p></li></ol><h4 id="用户自定义类加载器实现步骤" tabindex="-1"><a class="header-anchor" href="#用户自定义类加载器实现步骤" aria-hidden="true">#</a> 用户自定义类加载器实现步骤</h4><ol><li><p>开发人员可以通过继承抽象类 java.lang.classLoader 类的方式，实现自己的类加载器，以满足一些特殊的需求。</p></li><li><p>在 JDK1.2之前，在自定义类加载器时，总会去继承 classLoader 类并重写 loadclass() 方法，从而实现自定义的类加载类，但是在 JDK1.2 之后已不再建议用户去覆盖 loadclass() 方法，而是建议把自定义的类加载逻辑写在 findclass() 方法中。</p></li><li><p>在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承 URLClassLoader 类，这样就可以避免自己去编写 findclass() 方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。</p></li></ol><h4 id="classloader类" tabindex="-1"><a class="header-anchor" href="#classloader类" aria-hidden="true">#</a> ClassLoader类</h4><p>ClassLoader 类是一个抽象类，其后所有的类加载器都继承自ClassLoader（不包括启动类加载器）。</p><table><thead><tr><th>方法名称</th><th>描述</th></tr></thead><tbody><tr><td>getParent()</td><td>返回该加载器的超类加载器</td></tr><tr><td>loadClass(String name)</td><td>加载名为 name 的类，返回结果为 Java.lang.Class 类的实例</td></tr><tr><td>findClass(String name)</td><td>加载名为 name 的类，返回结果为 Java.lang.Class 类的实例</td></tr><tr><td>findLoadClass(String name)</td><td>查找名称为 name 的已经被加载过的类，返回结果为java.lang.Class的实例</td></tr><tr><td>defineClass(String name，byte[] b，int off，int len)</td><td>将字节数组 b 的内容转为一个 Java 类，返回结果为 java.lang.class的实例</td></tr><tr><td>resolveClass(Class&lt;?&gt; c)</td><td>连接指定的一个java类</td></tr></tbody></table><h4 id="获取classloader的途径" tabindex="-1"><a class="header-anchor" href="#获取classloader的途径" aria-hidden="true">#</a> 获取ClassLoader的途径</h4><ul><li><p>方式一：获取当前类的ClassLoader</p><p>clazz.getClassLoader()</p></li><li><p>方式二：获取当前上下文的ClassLoader</p><p>Thread.currentThread().getContextClassLoader()</p></li><li><p>方式三：获取系统的ClassLoader</p><p>ClassLoader.getSystemClassLoader()</p></li><li><p>方式四：获取调用者的ClassLoader</p><p>DriverManager.getCallerClassLoader()</p></li></ul><h3 id="双亲委派机制" tabindex="-1"><a class="header-anchor" href="#双亲委派机制" aria-hidden="true">#</a> 双亲委派机制</h3><p>​ Java 虚拟机对 class 文件采用的是按需加载的方式，也就是说当需要使用该类时才会将它的 class 文件加载到内存生成 class 对象。而且加载某个类的 class 文件时，Java 虚拟机采用的是双亲委派模式，即把请求交由父类处理，它是一种任务委派模式。</p><h4 id="工作原理" tabindex="-1"><a class="header-anchor" href="#工作原理" aria-hidden="true">#</a> 工作原理</h4><ol><li><p>如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行。</p></li><li><p>如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器。</p></li><li><p>如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。</p></li></ol><p>双亲委派的优势</p><ul><li><p>避免类的重复加载（向上可以被加载就不会继续委派，只加载一次）</p></li><li><p>保护程序安全，防止随意篡改核心API，如 Java.lang.String和java.lang.SamStart。如果引导类加载该类，可能出现问题造成破坏。</p></li></ul><figure><img src="/assets/双亲委派-c52ed12f.png" alt="双亲委派.png" tabindex="0" loading="lazy"><figcaption>双亲委派.png</figcaption></figure><p>程序说明：</p><p>​ 自定义的 java.lang.String 先由应用类加载器委托扩展类加载器，再由扩展类加载器委托给引导类加载器，引导类加载器只加载包名为 java、 javax、sun 等开头的类。因此真正加载的是String类，而不是自定义的String。</p><h4 id="沙箱安全机制" tabindex="-1"><a class="header-anchor" href="#沙箱安全机制" aria-hidden="true">#</a> 沙箱安全机制</h4><p>​ 自定义 String 类，但是在加载自定义 String 类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载 jdk 自带的文件( rt.jar包中 java\lang\string.class )，报错信息说没有main方法，就是因为加载的是 rt.jar 包中的String 类。这样可以保证对 java 核心源代码的保护，这就是沙箱安全机制。</p><h4 id="判断两个class对象是否为同一类" tabindex="-1"><a class="header-anchor" href="#判断两个class对象是否为同一类" aria-hidden="true">#</a> 判断两个Class对象是否为同一类</h4><ul><li><p>类的完整类名必须一致，包括包名。</p></li><li><p>加载这个类的classLoader(指classLoader实例对象)必须相同。</p><p>换句话说，在JVM中，即使这两个类对象(class对象)来源同一个class文件，被同一个虚拟机所加载，但只要加载它们的classLoader实例对象不同，那么这两个类对象也是不相等的。</p></li></ul><h4 id="对类加载器的引用" tabindex="-1"><a class="header-anchor" href="#对类加载器的引用" aria-hidden="true">#</a> 对类加载器的引用</h4><p>JVM 必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的。如果一个类型是由用户类加载器加载的，那么JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中。当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的。</p><h4 id="类的主动使用和被动使用" tabindex="-1"><a class="header-anchor" href="#类的主动使用和被动使用" aria-hidden="true">#</a> 类的主动使用和被动使用</h4><p>Java程序对类的使用方式分为：主动使用和被动使用。</p><p>主动使用，又分为七种情况：</p><ol><li><p>创建类的实例</p></li><li><p>访问某个类或接口的静态变量，或者对该静态变量赋值</p></li><li><p>调用类的静态方法</p></li><li><p>反射（比如：Class.forName(&quot;com.example. Test&quot;) )</p></li><li><p>初始化一个类的子类</p></li><li><p>Java虚拟机启动时被标明为启动类的类</p></li><li><p>JDK 7 开始提供的动态语言支持：</p><ol><li><p>java.lang.invoke.MethodHandle实例的解析结果</p></li><li><p>REFgetStatic、REF putstatic、REF invokeStatic句柄对应的类没有初始化，则初始化</p></li></ol></li></ol><p>除了以上七种情况，其他使用 Java 类的方式都被看作是对类的被动使用，都<strong>不会导致类的初始化。</strong></p><h2 id="运行时数据区及概述及线程" tabindex="-1"><a class="header-anchor" href="#运行时数据区及概述及线程" aria-hidden="true">#</a> 运行时数据区及概述及线程</h2><h3 id="运行时数据区结构概述" tabindex="-1"><a class="header-anchor" href="#运行时数据区结构概述" aria-hidden="true">#</a> 运行时数据区结构概述</h3><p>​ 内存是非常重要的系统资源，是硬盘和CPU的中间仓库及桥梁，承载着操作系统和应用程序的实时运行。 JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略，保证了JVM的高效稳定运行。不同的JVM对于内存的划分方式和管理机制存在着部分差异。</p><figure><img src="/assets/运行时数据区结构概述-b867f225.png" alt="运行时数据区结构概述.png" tabindex="0" loading="lazy"><figcaption>运行时数据区结构概述.png</figcaption></figure><p>说明：</p><ul><li><p>Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。</p></li><li><p>另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁。即：</p><p>​ <strong>每个线程：独立包括程序计数器、栈、本地栈。</strong></p><p>​ <strong>线程间共享：堆、堆外内存（永久代或元空间、代码缓存)</strong></p></li><li><p>如一个进程包含 n 个线程，则会有 n 个虚拟机栈、本地方法栈、程序计数器，它们共用 1 个方法区和堆区。</p><p>【大概：堆（占用95%空间），方法区（5%空间）】</p></li><li><p>JDK8 方法区为元空间，使用本地内存。（本地内存很大，方法区基本不出现溢出）</p></li><li><p>每一个JVM只有一个Runtime实例，为运行时环境。</p></li></ul><h3 id="jvm中的线程说明" tabindex="-1"><a class="header-anchor" href="#jvm中的线程说明" aria-hidden="true">#</a> JVM中的线程说明</h3><h4 id="说明一" tabindex="-1"><a class="header-anchor" href="#说明一" aria-hidden="true">#</a> 说明一：</h4><ol><li><p>线程是一个程序里的运行单元。JVM允许一个应用有多个线程并行的执行。</p></li><li><p><mark>在Hotspot JVM里，每个线程都与操作系统的本地线程直接映射。</mark></p></li><li><p>当一个 Java 线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也会回收。</p></li><li><p><mark>操作系统负责所有线程的安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，它就会调用Java线程中的run()方法。</mark></p></li><li><p>Java线程的准备：PC寄存器、本地方法栈、虚拟机栈</p></li><li><p>如果 run 方法正常执行结束，那么 Java 线程执行终止后，本地线程也会回收，但如果出现了异常，本地线程会考虑JVM是否终止（是否全为守护线程）。</p></li></ol><h4 id="说明二" tabindex="-1"><a class="header-anchor" href="#说明二" aria-hidden="true">#</a> 说明二：</h4><p>如果你使用 jconsole 或者是任何一个调试工具，都能看到在后台有许多线程在运行。这些后台线程不包括调用 public static void main(String [ ])的 main 线程以及所有这个 main 线程自己创建的线程。这些主要的后台系统线程在Hotspot JVM里主要是以下几类：</p><ol><li><p><strong>虚拟机线程</strong>︰这种线程的操作是需要 JVM 达到<mark>安全点</mark>才会出现。这些操作必须在不同的线程中发生的原因是它们都需要JVM达到安全点，这样堆才不会变化。</p><p>这种线程的执行类型包括 &quot;stop-the-world&quot; 的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销。</p></li><li><p><strong>周期任务线程</strong>：这种线程是时间周期事件的体现(比如中断)，他们一般用于周期性操作的调度执行。</p></li><li><p><strong>GC线程</strong>：这种线程对在JVM里不同种类的垃圾收集行为提供了支持。</p></li><li><p><strong>编译线程</strong>：这种线程在运行时会将字节码编译成到本地代码。</p></li><li><p><strong>信号调度线程</strong>：这种线程接收信号并发送给JVM，在它内部通过调用适当的方法进行处理。</p></li></ol><h3 id="程序计数器" tabindex="-1"><a class="header-anchor" href="#程序计数器" aria-hidden="true">#</a> 程序计数器</h3><p>Oracle的介绍：<a href="https://docs.oracle.com/en/java/javase/19/" target="_blank" rel="noopener noreferrer">https://docs.oracle.com/en/java/javase/19/<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><h4 id="pc-register-介绍" tabindex="-1"><a class="header-anchor" href="#pc-register-介绍" aria-hidden="true">#</a> PC Register 介绍</h4><p>JVM中的程序计数寄存器(Program counter Register)中，Register 的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。CPU只有把数据装载到寄存器才能够运行。</p><p>这里，并非是广义上所指的物理寄存器，或许将其翻译为PC计数器（或指令计数器）会更加贴切(也称为程序钩子)，并且也不容易引起一些不必要的误会。</p><p><mark>JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟。（软件层面）</mark></p><h4 id="pc-register-作用" tabindex="-1"><a class="header-anchor" href="#pc-register-作用" aria-hidden="true">#</a> PC Register 作用</h4><p><strong>PC寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令。</strong></p><figure><img src="/assets/PC寄存器-bb11979c.png" alt="PC寄存器.png" tabindex="0" loading="lazy"><figcaption>PC寄存器.png</figcaption></figure><h4 id="pc寄存器的概述" tabindex="-1"><a class="header-anchor" href="#pc寄存器的概述" aria-hidden="true">#</a> PC寄存器的概述</h4><ol><li><p><strong>它是一块很小的内存空间，几乎可以忽略不记。也是运行速度最快的存储区域。在JVM规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。</strong></p></li><li><p><strong>任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；或者，如果是在执行native方法(C/C++)，则是未指定值（undefned) 。</strong></p></li><li><p><strong>它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</strong></p></li><li><p><strong>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。</strong></p></li><li><p><strong>它是唯一一个在Java虚拟机规范中没有规定任何 outOtMemoryError 情况的区域。</strong></p></li></ol><ul><li><p><strong>对于堆和方法区，有GC回收</strong></p></li><li><p><strong>对于堆、方法区、栈（虚拟机栈、本地方法栈没有GC），会有OOM</strong></p></li><li><p><strong>但PC寄存器不会有GC和OOM</strong></p></li></ul><h4 id="pc寄存器的两个问题" tabindex="-1"><a class="header-anchor" href="#pc寄存器的两个问题" aria-hidden="true">#</a> PC寄存器的两个问题</h4><ol><li><p>使用PC寄存器存储字节码指令地址的作用</p><p>为什么使用PC寄存器记录当前线程的执行地址呢？</p><p>因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。</p></li><li><p>PC寄存器为什么会被设定为线程私有?</p><p>（肯定不能共享）所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU会不停地做任务切换，这样必然导致经常中断或恢复，如何保证分毫无差呢﹖</p><ul><li><p>为了能多准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。</p></li><li><p>由于CPU时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。</p></li><li><p>每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。</p><p>CPU时间片：即CPU分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片。</p></li></ul></li></ol><h2 id="虚拟机栈" tabindex="-1"><a class="header-anchor" href="#虚拟机栈" aria-hidden="true">#</a> 虚拟机栈</h2><h3 id="虚拟机栈的概述" tabindex="-1"><a class="header-anchor" href="#虚拟机栈的概述" aria-hidden="true">#</a> 虚拟机栈的概述</h3><h4 id="虚拟机栈出现的背景" tabindex="-1"><a class="header-anchor" href="#虚拟机栈出现的背景" aria-hidden="true">#</a> 虚拟机栈出现的背景</h4><p><mark>由于跨平台性的设计，Java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的。</mark></p><p><mark>优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。</mark></p><p><strong>栈是运行时的单位，而堆是存储的单位。</strong></p><p>即：栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放、放在哪儿。</p><h4 id="java虚拟机栈介绍" tabindex="-1"><a class="header-anchor" href="#java虚拟机栈介绍" aria-hidden="true">#</a> Java虚拟机栈介绍</h4><ol><li><p>Java虚拟机栈是什么</p><ul><li><p>Java虚拟机栈（Java virtual Machine stack)，早期也叫 Java 栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存每一个栈帧（Stack Frame），对应着每一次的 Java方法调用。</p></li><li><p>是线程私有的</p></li></ul></li><li><p>生命周期</p><p>生命周期和线程一致。</p></li><li><p>作用</p><p>主要负责 Java 程序的运行，它保存方法的局部变量（8种基本的数据类型和对象引用地址）、部分结果，并参与方法的调用和返回。</p></li></ol><h4 id="栈的优点" tabindex="-1"><a class="header-anchor" href="#栈的优点" aria-hidden="true">#</a> 栈的优点</h4><ol><li><p><strong>栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器。</strong></p></li><li><p>JVM直接对 Java 栈的操作只有两个：</p><p>每个方法执行，伴随着进栈（入栈、压栈）、执行结束后的出栈工作</p></li><li><p>对于栈来说不存在垃圾回收问题</p></li></ol><h4 id="栈中可能出现的异常" tabindex="-1"><a class="header-anchor" href="#栈中可能出现的异常" aria-hidden="true">#</a> 栈中可能出现的异常</h4><ul><li><p>Java 虚拟机规范允许 Java 栈的大小是动态的或者是固定不变的。</p></li><li><p>如果采用固定大小的 Java 虚拟机栈，那每一个线程的 Java 虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过 Java 虚拟机栈允许的最大容量，Java 虚拟机将会抛出一个 StackOverflowError 异常。</p></li><li><p>如果 Java 虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那 Java 虚拟机将会抛出一个 OutofMemoryError 异常。</p></li></ul><h4 id="设置栈内存大小" tabindex="-1"><a class="header-anchor" href="#设置栈内存大小" aria-hidden="true">#</a> 设置栈内存大小</h4><p>可以使用参数 -Xss 选项来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度。</p><p><a href="https://docs.oracle.com/en/java/javase/11/tools/java.html#GUID-3B1CE181-CD30-4178-9602-230B800D4FAE" target="_blank" rel="noopener noreferrer">https://docs.oracle.com/en/java/javase/11/tools/java.html#GUID-3B1CE181-CD30-4178-9602-230B800D4FAE<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><blockquote><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>-Xss size
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>Sets the thread stack size (in bytes). Append the letter <code>k</code> or <code>K</code> to indicate KB, <code>m</code> or <code>M</code> to indicate MB, and <code>g</code> or <code>G</code> to indicate GB. The default value depends on the platform:</p><ul><li>Linux/x64 (64-bit): 1024 KB</li><li>macOS (64-bit): 1024 KB</li><li>Oracle Solaris/x64 (64-bit): 1024 KB</li><li>Windows: The default value depends on virtual memory</li></ul><p>The following examples set the thread stack size to 1024 KB in different units:</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>Copy-Xss1m
-Xss1024k
-Xss1048576
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></blockquote><h3 id="栈的存储结构和运行原理" tabindex="-1"><a class="header-anchor" href="#栈的存储结构和运行原理" aria-hidden="true">#</a> 栈的存储结构和运行原理</h3><h4 id="栈中存储什么" tabindex="-1"><a class="header-anchor" href="#栈中存储什么" aria-hidden="true">#</a> 栈中存储什么？</h4><ol><li><p>每个线程都有自己的栈，栈中的数据都是以栈帧(stack Frame）的格式存在。</p></li><li><p>在这个线程上正在执行的每个方法都各自对应一个栈帧(stack Frame）。</p></li><li><p>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。</p></li></ol><h4 id="栈的运行原理" tabindex="-1"><a class="header-anchor" href="#栈的运行原理" aria-hidden="true">#</a> 栈的运行原理</h4><ol><li><p>JVM直接对Java栈的操作只有两个，就是对栈帧的压栈和出栈，遵循&quot;先进后出&quot;或&quot;后进先出&quot;原则。</p></li><li><p>在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的，这个栈帧被称为当前栈帧(Current Frame)，与当前栈帧相对应的方法就是当前方法(currentMethod)，定义这个方法的类就是当前类(current class)。</p></li><li><p>执行引擎运行的所有字节码指令只针对当前栈帧进行操作。</p></li><li><p>如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧。</p></li><li><p>不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧之中引甲另外一个线程的栈帧。</p></li><li><p>如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。</p></li><li><p>Java方法有两种返回函数的方式，一种是正常的函数返回，使用return指令；另外一种是抛出异常（由上一个栈帧对应的方法进行处理，否则继续抛出）。不管使用哪种方式，都会导致栈帧被弹出。</p></li></ol><h4 id="栈帧的内部结构" tabindex="-1"><a class="header-anchor" href="#栈帧的内部结构" aria-hidden="true">#</a> 栈帧的内部结构</h4><p>每个栈帧中存储着：（局部变量表和操作数栈主要影响栈帧的大小）</p><ol><li><p>局部变量表（Local variables)</p></li><li><p>操作数栈（operand stack)(或表达式栈)</p></li><li><p>动态链接(Dynamic Linking)(或指向运行时常量池的方法引用)</p></li><li><p>方法返回地址（Return Address）(或方法正常退出或者异常退出的定义)</p></li><li><p>一些附加信息</p></li></ol><h3 id="局部变量表" tabindex="-1"><a class="header-anchor" href="#局部变量表" aria-hidden="true">#</a> 局部变量表</h3><h4 id="几点说明" tabindex="-1"><a class="header-anchor" href="#几点说明" aria-hidden="true">#</a> 几点说明</h4><ol><li><p>局部变量表也被称之为<strong>局部变量数组</strong>或本地变量表。</p></li><li><p>定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量这些数据类型包括各类基本数据类型、对象引用（reference)，以及returnAddress类型。</p></li><li><p>由于局部变量表是建立在线程的栈上，是线程的私有数据，因此不存在数据安全问题。</p></li><li><p><strong>局部变量表所需的容量大小是在编译期确定下来的</strong>，并保存在方法的Code属性的maximum local variables数据项中。在方法运行期间是不会改变局部变量表的大小的。</p></li><li><p>方法嵌套调用的次数由栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多。对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。</p></li><li><p>局部变量表中的变量只在当前方法调用中有效。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。</p></li></ol><h4 id="字节码中方法的内部结构" tabindex="-1"><a class="header-anchor" href="#字节码中方法的内部结构" aria-hidden="true">#</a> 字节码中方法的内部结构</h4><p>V代表返回值类型：void</p><h4 id="关于slot的理解" tabindex="-1"><a class="header-anchor" href="#关于slot的理解" aria-hidden="true">#</a> 关于Slot的理解</h4><h5 id="几点说明-1" tabindex="-1"><a class="header-anchor" href="#几点说明-1" aria-hidden="true">#</a> 几点说明</h5><ol><li><p>参数值的存放总是在局部变量数组的index0开始，到数组长度-1的索引结束。</p></li><li><p>局部变量表，最基本的存储单元是slot(变量槽)</p></li><li><p>局部变量表中存放编译期可知的各种基本数据类型(8种)，引用类型(reference) ，returnAddress类型的变量。</p></li><li><p>在局部变量表里，32位以内的类型只占用一个slot(包括returnAddress类型），64位的类型(long和double)占用两个slot。</p><ul><li><p>byte、short、char在存储前被转换为int，boolean也被转换为int，0表示false，非0表示true。</p></li><li><p>long和double 则占据两个slot。</p></li></ul></li><li><p>JVM会为局部变量表中的每一个slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值。</p></li><li><p>当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会按照顺序被复制到局部变量表中的每一个slot上。</p></li><li><p>如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可。(比如访问long或double类型变量)</p></li><li><p>如果当前帧是由构造方法或者实例方法创建的，那么该对象引用this将会存放在index为0的slot处，其余的参数按照参数表顺序继续排列。</p><p>实例方法默认是有this的</p><p>如果不使用变量接收一个方法的返回值，那么slot中不会出现返回值。</p></li><li><p>在栈帧中，与性能调优关系最为密切的部分就是前面提到的局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递。</p></li><li><p>局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。</p></li></ol><h5 id="slot的重复利用" tabindex="-1"><a class="header-anchor" href="#slot的重复利用" aria-hidden="true">#</a> Slot的重复利用</h5><p>​ 栈帧中的局部变量表中的槽位是可以重用的，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变量就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。</p><p>变量c使用之前会先使用已经销毁的变量b占据的slot的位置。（序号相同）</p><p>在方法或语句中出现的{}就称为普通代码块。普通代码块和一般语句的执行顺序由他们在代码中出现的次序决定，先出现先执行。</p><h4 id="静态变量与局部变量的对比" tabindex="-1"><a class="header-anchor" href="#静态变量与局部变量的对比" aria-hidden="true">#</a> 静态变量与局部变量的对比</h4><p>参数表分配完毕之后，再根据方法体内定义的变量的顺序和作用域分配。</p><p>我们知道类变量表有两次初始化的机会，第一次是在&quot;准备阶段&quot;，执行系统初始化，对类变量设置零值，另一次则是在&quot;初始化&quot;阶段，赋予程序员在代码中定义的初始值。</p><p>和类变量初始化不同的是，局部变量表不存在系统初始化的过程，这意味着一旦定义了局部变量则必须人为的初始化，否则无法使用。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test5</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">int</span> num<span class="token punctuation">;</span>
        <span class="token comment">//必须显示赋值</span>
        <span class="token comment">// System.out.println(num);</span>
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在栈帧中，与性能调优关系最为密切的部分就是前面提到的局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递。</p><p>局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。</p><h3 id="操作数栈" tabindex="-1"><a class="header-anchor" href="#操作数栈" aria-hidden="true">#</a> 操作数栈</h3><p>操作数栈使用数组（链表）实现</p><p>每一个独立的栈帧中除了包含局部变量表以外，还包含一个后进先出(Last-In-First-Out)的操作数栈，也可以称之为表达式栈(Expression Stack) 。</p><p>操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈(push) /出栈(pop)。</p><p>某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈。</p><p>比如：执行复制、交换、求和等操作。</p><p>操作数栈，主要用于保存计算过程的中间结果，同时作为计算过程中变量</p><p>临时的存储空间。</p><p>操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这个方法的操作数栈是空的。</p><p>每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的Code属性中，为max_stack的值。</p><p>栈中的任何一个元素都是可以任意的Java数据类型。</p><p>32bit的类型占用一个栈单位深度</p><p>64bit的类型占用两个栈单位深度</p><p>操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈(push)和出栈(pop)操作来完成一次数据访问。</p><p>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新PC寄存器中下一条需要执行的字节码指令。</p><p>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证。</p><p>另外，我们说Java虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈。</p><p>没有返回值的操作数栈示例：</p><p>有返回值的操作数栈示例：</p><p>i++与++i的区别：</p><h3 id="栈顶缓存技术" tabindex="-1"><a class="header-anchor" href="#栈顶缓存技术" aria-hidden="true">#</a> 栈顶缓存技术</h3><p>前而提过，基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派(instruction dispatch) 次数和内存读/写次数。</p><p>由于操作数是存储在内存中的，因此频繁地执行内存读/写操作必然会影响执行速度。为了解决这个问题，Hotspot JVM的设计者们提出了栈顶缓存(Tos， Top-of-Stack Cashing) 技术，将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率。</p><h3 id="动态链接" tabindex="-1"><a class="header-anchor" href="#动态链接" aria-hidden="true">#</a> 动态链接</h3><p>帧数据区：方法返回地址 + 一些附加信息</p><p>每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接(Dynamic Linking)。比如: invokedynamic指令。</p><p>在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用(symbolic Reference) 保存在class文件的常量池里。</p><p>比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。</p><p>字节码中的常量池运行以后就放在方法区。（运行时常量池）</p><p>为什么需要常量池?</p><p>常量池的作用，就是为了提供- -些符号和常量，便于指令的识别。</p><h3 id="方法的调用" tabindex="-1"><a class="header-anchor" href="#方法的调用" aria-hidden="true">#</a> 方法的调用</h3><h4 id="动态链接与静态链接" tabindex="-1"><a class="header-anchor" href="#动态链接与静态链接" aria-hidden="true">#</a> 动态链接与静态链接</h4><p>在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关。</p><p>静态链接：</p><p>当一个字节码文件被装载进JVM内部时，如果被调用的目标方法在编译期可知，且运行期保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接。</p><p>动态链接：</p><p>如果被调用的方法在编译期无法被确定下来，也就是说，只能够在程序运行</p><p>期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称之为动态链接。</p><p>对应的方法的绑定机制为：早期绑定(Early Binding) 和晚期绑定(Late Binding)。绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次。</p><h4 id="早期绑定与晚期绑定" tabindex="-1"><a class="header-anchor" href="#早期绑定与晚期绑定" aria-hidden="true">#</a> 早期绑定与晚期绑定</h4><p>早期绑定：</p><p>早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时,</p><p>即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪-一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。</p><p>晚期绑定：</p><p>如果被调用的方法在编译期无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法，这种绑定方式也就被称之为晚期绑定。</p><p>随着高级语言的横空出世，类似于Java-样的基于面向对象的编程语言如今</p><p>越来越多，尽管这类编程语言在语法风格上存在一定的差别，但是它们彼此之间始终保持着一个共性，那就是都支持封装、继承和多态等面向对象特性, 既然这一类的编程语言具备多态特性，那么自然也就具备早期绑定和晚期绑定两种绑定方式。</p><p>Java中任何一个普通的方法其实都具备虛函数的特征，它们相当于C++语言</p><p>中的虚函数(C++中则需要使用关键字virtual来显式定义)。如果在Java程序中不希望某个方法拥有虚函数的特征时，则可以使用关键字final来标，记这个方法。</p><h4 id="虚方法与非虚方法" tabindex="-1"><a class="header-anchor" href="#虚方法与非虚方法" aria-hidden="true">#</a> 虚方法与非虚方法</h4><p>非虚方法：</p><p>如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。</p><p>这样的方法称为非虚方法。</p><p>静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法。</p><p>其他方法称为虚方法。</p><p>虚拟机中提供了以下几条方法调用指令：</p><p>普通调用指令：</p><p>\1. invokestatic: 调用静态方法，解析阶段确定唯一方法版本</p><p>\2. invokespecial: 调用&lt;init&gt;方法、私有及父类方法，解析阶段确定唯一方法版本</p><p>\3. invokevirtual: 调用所有虚方法</p><p>\4. invokeinterface: 调用接口方法</p><p>动态调用指令：</p><p>\5. invokedynamic: 动态解析出需要调用的方法，然后执行</p><p>前四条指令固化在虚拟机内部，方法的调用执行不可人为干预，而invokedynamic指令则支持由用户确定方法版本。其中invokestatic指令和invokespecial指令调用的方法称为非虚方法，其余的(final修饰的除外)称为虚方法。</p><p>关于invokedynamic指令</p><p>JVM字节码指令集一直比较稳定，一直到Java7中才增加了一个invokedynamic指令，这是Java为了实现【动态类型语言】支持而做的一种改进。</p><p>但是在Java7中并没有提供直接生成invokedynamic指令的方法，需要借助ASM这种底层字节码工具来产生invokedynamic指令。直到Java8的Lambda表达式的出现，invokedynamic指令的生成，在Java中才有了直接的生成方式。</p><p>Java7中增加的动态语言类型支持的本质是对Java虚拟机规范的修改，而不是对Java语言规则的修改，这一块相对来讲比较复杂，增加了虚拟机中的方法调用，最直接的受益者就是运行在Java平台的动态语言的编译器。</p><p>动态类型语言和静态类型语言：</p><p>动态类型语言和静态类型语言两者的区别就在于对类型的检查是在编译期还是在运行期，满足前者就是静态类型语言，反之是动态类型语言。</p><p>说的再直白一点就是，静态类型语言是判断变量自身的类型信息；动态类型</p><p>语言是判断变量值的类型信息，变量没有类型信息，变量值才有类型信息，</p><p>这是动态语言的一个重要特征。</p><p>Java是静态类型语言</p><h4 id="方法重写的本质与虚方法表的使用" tabindex="-1"><a class="header-anchor" href="#方法重写的本质与虚方法表的使用" aria-hidden="true">#</a> 方法重写的本质与虚方法表的使用</h4><p>Java语言中方法重写的本质：</p><p>\1. 找到操作数栈顶的第一个元素所执行的对象的实际类型，记作C。</p><p>\2. 如果在类型中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限松验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回java.lang.IllegalAccessError异常。</p><p>\3. 否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程。</p><p>\4. 如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常。</p><p>IllegalAccessError介绍：</p><p>程序试图访问或修改一个属性或调用一个方法，这个属性或方法，你没有权限访问。一般的，这个会引起编译器异常。这个错误如果发生在运行时，就说明一个类发生了不兼容的改变。</p><p>【在子类对象中找到与常量中描述相符的方法，则进行权限校验】</p><p>在面向对象的编程中，会很频繁的使用到动态分派，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。因此，为了提高性能，JVM采用在类的方法区建立一个虚方法表(virtual method table) (非虚方法不会出现在表中)来实现。使用索引表来代替查找。</p><p>每个类中都有一个虚方法表，表中存放着各个方法的实际入口。</p><p>那么虚方法表什么时候被创建?</p><p>虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM会把该类的方法表也初始化完毕。</p><h3 id="方法返回地址" tabindex="-1"><a class="header-anchor" href="#方法返回地址" aria-hidden="true">#</a> 方法返回地址</h3><p>存放调用该方法的pc寄存器的值。</p><p>一个方法的结束，有两种方式:</p><p>正常执行完成</p><p>出现未处理的异常，非正常退出</p><p>无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。</p><p>当一个方法开始执行后，只有两种方式可以退出这个方法：</p><p>1、执行引擎遇到任意一个方法返回的字节码指令(return) ，会有返回值传递给上层的方法调用者，简称正常完成出口：</p><ol><li><p>一个方法在正常调用完成之后究竟需要使用哪个返回指令还需要根据方法返回值的实际数据类型而定。</p></li><li><p>在字节码指令中，返回指令包含ireturn (当返回值是boolean、 byte、 char、</p></li></ol><p>short和int类型时使用)、lreturn、freturn、dreturn以及areturn（引用地址），另外还有一个return指令供声明为void的方法、实例初始化方法、类和接口的初始化方法使用。</p><p>2、在方法执行的过程中遇到了异常(Exception)，并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出。简称异常完成出口。</p><p>方法执行过程中抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码。</p><p>【字节码指令从4到8出现异常跳转至11进行处理】</p><p>本质上，方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。</p><p>正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。</p><h3 id="一些附加信息" tabindex="-1"><a class="header-anchor" href="#一些附加信息" aria-hidden="true">#</a> 一些附加信息</h3><p>栈帧中还允许携带与Java虚拟机实现相关的一些附加信息。例如，对程序调试提供支持的信息。</p><h3 id="相关5个问题" tabindex="-1"><a class="header-anchor" href="#相关5个问题" aria-hidden="true">#</a> 相关5个问题</h3><p>\1. 设置栈的大小</p><p>通过-Xss设置大小</p><p>\2. 调整栈的大小，就能保证不出现溢出吗？</p><p>不能，往小的调。</p><p>\3. 分配的栈内存越大越好吗？</p><p>不是，大就会占用其他的进程</p><p>\4. 垃圾回收是否会涉及虚拟机栈？</p><p>不会。</p><table><thead><tr><th></th><th>OOM</th><th>GC</th></tr></thead><tbody><tr><td>PC寄存器</td><td>没有</td><td>没有</td></tr><tr><td>虚拟机栈</td><td>有</td><td>没有</td></tr><tr><td>本地方法栈</td><td>有</td><td>没有</td></tr><tr><td>堆</td><td>有</td><td>有</td></tr><tr><td>方法区</td><td>有</td><td>有</td></tr></tbody></table><p>\1. 方法中定义的局部变量是否一定线程安全</p><h2 id="本地方法接口-java-method-interface" tabindex="-1"><a class="header-anchor" href="#本地方法接口-java-method-interface" aria-hidden="true">#</a> 本地方法接口（Java Method Interface）</h2><p>什么是本地方法?</p><p>简单地讲，一个Native Method就是一个Java调用非Java代码的接口。一个Native Method是这样一个Java方法:该方法的实现由非Java语言实现，比如</p><p>C。这个特征并非Java所特有，很多其它的编程语言都有这一机制，比如在C++中，你可以用extern &quot;C&quot; 告知C++编译器去调用一个C的函数。</p><p>&quot;A native method is a Java method whose implementation is provided by non-java code.&quot;</p><p>在定义一个native method时，并不提供实现体(有些像定义一个Java interface)，因为其实现体是由非java语言在外面实现的。</p><p>本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合C/C++程序。</p><h2 id="本地方法栈-native-method-stack" tabindex="-1"><a class="header-anchor" href="#本地方法栈-native-method-stack" aria-hidden="true">#</a> 本地方法栈（Native Method Stack）</h2><p>Java虚拟机栈用于管理Java方法的调用，而本地方法栈用于管理本地方法</p><p>的调用。</p><p>本地方法栈，也是线程私有的。</p><p>允许被实现成固定或者是可动态扩展的内存大小。(在内存溢出方面是相同的)</p><p>Ø 如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会抛出一个stackoverflowError 异常。</p><p>Ø 如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么Java虚拟机将会抛出一个outofMemoryError 异常。</p><p>本地方法是使用C语言实现的。</p><p>它的具体做法是Native Method stack中登记native方法，在Execution Engine执行时加载本地方法库。</p><p>当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟</p><p>机限制的世界。它和虚拟机拥有同样的权限。</p><p>Ø 本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区。</p><p>Ø 它甚至可以直接使用本地处理器中的寄存器</p><p>Ø 直接从本地内存的堆中分配任意数量的内存。</p><p>并不是所有的JVM都支持本地方法。因为Java虚拟机规范并没有明确要求</p><p>本地方法栈的使用语言、具体实现方式、数据结构等。如果JVM产品不打算支持native方法，也可以无需实现本地方法栈。</p><p>在Hotspot JVM中， 直接将本地方法栈和虚拟机栈合二为一。</p><h2 id="堆" tabindex="-1"><a class="header-anchor" href="#堆" aria-hidden="true">#</a> 堆</h2><h3 id="堆的核心描述" tabindex="-1"><a class="header-anchor" href="#堆的核心描述" aria-hidden="true">#</a> 堆的核心描述</h3><ol><li><p>一个JVM实例只存在一个堆内存，堆也是 Java 内存管理的核心区域。</p></li><li><p>Java 堆区在 JVM 启动的时候即被创建，其空间大小也就确定了。是 JVM 管理的最大一块内存空间。</p></li><li><p>堆内存的大小是可以调节的。</p></li><li><p>《Java虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。</p></li><li><p><strong>所有的线程共享Java堆，共享数据并发性不好，因此在这里还可以划分线程私有的缓冲区（Thread Local Allocation Buffer, TLAB 。</strong></p></li></ol><p><strong>（即堆不是全部共享的）</strong></p><p>​ <strong>设置堆内存：初始（-Xms20m）最大（-Xmx20m）</strong></p><p>Idea中在vm options 中设置 -Xms 和 -Xmx，运行程序，使用 Jdk 自带的 jvisualvm.exe 查看堆内存的大小。</p><p>示例：每个进程拥有独立的一份堆空间。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token doc-comment comment">/**
 * 堆内存大小设置：
 * -Xms10m -Xmx10m
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HeadDemo01</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;start...&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;shutdown....&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token doc-comment comment">/**
 * 堆内存大小设置：
 * -Xms15m -Xmx15m
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HeadDemo02</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;start...&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;shutdown....&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用 Jdk 自带的 jvisualvm.exe 查看堆内存的大小：</p><p>【注意：使用管理员权限运行，否则会报： jvisualvm 无法检测到本地java应用程序】</p><figure><img src="/assets/使用jvisualvm查看堆内存大小-ff876bf4.png" alt="使用jvisualvm查看堆内存大小.png" tabindex="0" loading="lazy"><figcaption>使用jvisualvm查看堆内存大小.png</figcaption></figure><ol start="6"><li>《Java虛拟机规范》中对 Java 堆的描述是：<strong>所有的对象实例以及数组都应当在运行时分配在堆上</strong>。(The heap is the run-time data area from which memory for all cla3s instances and arrays is allocated )</li></ol><p>注意: “几乎”所有的对象实例都在这里分配内存。——从实际使用角度看的。</p><ol start="7"><li><strong>数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。</strong></li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token doc-comment comment">/**
 * 对象引用消失，堆里面的对象不会立即GC
 * 如果GC过于频繁，就会影响用户线程，必要时可以将堆内存增大
 * 先进行编译，再使用jclasslib查看详情
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SimpleHeap</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> id<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">SimpleHeap</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> id<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
	
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">SimpleHeap</span> simpleHeap01 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleHeap</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">SimpleHeap</span> simpleHeap02 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleHeap</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr01 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr02 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>字节码信息：new 创建对象</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code> <span class="token number">0</span> <span class="token keyword">new</span> #<span class="token number">3</span> <span class="token operator">&lt;</span>com<span class="token operator">/</span>example<span class="token operator">/</span>java<span class="token operator">/</span><span class="token class-name">SimpleHeap</span><span class="token operator">&gt;</span>
 <span class="token number">3</span> dup
 <span class="token number">4</span> iconst_1
 <span class="token number">5</span> invokespecial #<span class="token number">4</span> <span class="token operator">&lt;</span>com<span class="token operator">/</span>example<span class="token operator">/</span>java<span class="token operator">/</span><span class="token class-name">SimpleHeap</span><span class="token punctuation">.</span><span class="token generics"><span class="token punctuation">&lt;</span>init<span class="token punctuation">&gt;</span></span> <span class="token operator">:</span> <span class="token punctuation">(</span><span class="token class-name">I</span><span class="token punctuation">)</span><span class="token class-name">V</span><span class="token operator">&gt;</span>
 <span class="token number">8</span> astore_1
 <span class="token number">9</span> <span class="token keyword">new</span> #<span class="token number">3</span> <span class="token operator">&lt;</span>com<span class="token operator">/</span>example<span class="token operator">/</span>java<span class="token operator">/</span><span class="token class-name">SimpleHeap</span><span class="token operator">&gt;</span>
<span class="token number">12</span> dup
<span class="token number">13</span> iconst_1
<span class="token number">14</span> invokespecial #<span class="token number">4</span> <span class="token operator">&lt;</span>com<span class="token operator">/</span>example<span class="token operator">/</span>java<span class="token operator">/</span><span class="token class-name">SimpleHeap</span><span class="token punctuation">.</span><span class="token generics"><span class="token punctuation">&lt;</span>init<span class="token punctuation">&gt;</span></span> <span class="token operator">:</span> <span class="token punctuation">(</span><span class="token class-name">I</span><span class="token punctuation">)</span><span class="token class-name">V</span><span class="token operator">&gt;</span>
<span class="token number">17</span> astore_2
<span class="token number">18</span> bipush <span class="token number">10</span>
<span class="token number">20</span> newarray <span class="token number">10</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>
<span class="token number">22</span> astore_3
<span class="token number">23</span> bipush <span class="token number">10</span>
<span class="token number">25</span> anewarray #<span class="token number">5</span> <span class="token operator">&lt;</span>java<span class="token operator">/</span>lang<span class="token operator">/</span><span class="token class-name">Object</span><span class="token operator">&gt;</span>
<span class="token number">28</span> astore <span class="token number">4</span>
<span class="token number">30</span> <span class="token keyword">return</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="8"><li><p>在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。<strong>【频繁GC影响用户进程的执行】</strong></p></li><li><p>堆，是GC（Garbage Collection, 垃圾收集器）执行垃圾回收的重点区域。</p></li></ol><h3 id="堆的核心描述-内存细分" tabindex="-1"><a class="header-anchor" href="#堆的核心描述-内存细分" aria-hidden="true">#</a> 堆的核心描述：内存细分</h3><p>现代垃圾收集器大部分基于分代收集理论设计，堆空间细分为：</p><p>Java 7 及之前堆内存逻辑上分为三部分：新生区 + 养老区 + <mark>永久区</mark></p><blockquote><p>Young Generation Space 新生区 Young/New 【又被划分为Eden区和Survivor区】</p><p>Tenure generation space 养老区 old/Tenure</p><p>Permanent Space 永久区 Perm</p></blockquote><p>Java 8及之后堆内存逻辑上分为三部分：新生区 + 养老区 + <mark>元空间</mark></p><blockquote><p>Young Generation Space 新生区 Young/New 【又被划分为Eden区和Survivor区】</p><p>Tenure generation space 养老区 old/Tenure</p><p>Meta Space 元空间 Meta</p></blockquote><p>一般约定：【新生区 = 新生代 = 年轻代 养老区 = 老年区 = 老年代 永久区 = 永久代】</p><p><strong>Visual GC 插件安装：</strong></p><p>使用 jvisualvm 查看堆内存详细信息，安装 Visual GC 插件【相当于一个可视化插件】：工具|插件|搜索|安装|重启</p><p>如果安装出现网络问题，则修改 URL：<a href="https://visualvm.github.io/archive/uc/8u40/updates.xml.gz" target="_blank" rel="noopener noreferrer">https://visualvm.github.io/archive/uc/8u40/updates.xml.gz<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><p>使用示例：</p><p>修改HeapDemo01：-Xms10m -Xmx10m，使用 Visual GC 查看：</p><p>注意：<strong>【元空间/永久代只是逻辑区域】</strong></p><p>![使用Visual GC查看堆内存空间大小.png](JVM/使用Visual GC查看堆内存空间大小.png)</p><p>上图说明：</p><p><strong>Survivor 0和Survivor 1对于垃圾回收只能有一个区域存储数据，新生代的大小是Eden Space+ Survivor0/1。</strong></p><p>也可以在控制台打印**【注意该参数在程序运行完成以后才会打印】**，增加 vm 参数：-XX:+PringGCDetails</p><p>修改 SimpleHeap：-Xms10m -Xmx10m -XX:+PrintGCDetails</p><p>切换不同的 jdk 版本，查看 Metaspace/</p><p>对于jdk8，对应元空间 Metaspace：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Heap</span>
 <span class="token class-name">PSYoungGen</span>      total <span class="token number">2560</span>K<span class="token punctuation">,</span> used <span class="token number">1703</span>K <span class="token punctuation">[</span><span class="token number">0x00000000ffd00000</span><span class="token punctuation">,</span> <span class="token number">0x0000000100000000</span><span class="token punctuation">,</span> <span class="token number">0x0000000100000000</span><span class="token punctuation">)</span>
  eden space <span class="token number">2048</span>K<span class="token punctuation">,</span> <span class="token number">83</span><span class="token operator">%</span> used <span class="token punctuation">[</span><span class="token number">0x00000000ffd00000</span><span class="token punctuation">,</span><span class="token number">0x00000000ffea9d50</span><span class="token punctuation">,</span><span class="token number">0x00000000fff00000</span><span class="token punctuation">)</span>
  from space <span class="token number">512</span>K<span class="token punctuation">,</span> <span class="token number">0</span><span class="token operator">%</span> used <span class="token punctuation">[</span><span class="token number">0x00000000fff80000</span><span class="token punctuation">,</span><span class="token number">0x00000000fff80000</span><span class="token punctuation">,</span><span class="token number">0x0000000100000000</span><span class="token punctuation">)</span>
  <span class="token keyword">to</span>   <span class="token namespace">space</span> <span class="token number">512</span>K<span class="token punctuation">,</span> <span class="token number">0</span><span class="token operator">%</span> used <span class="token punctuation">[</span><span class="token number">0x00000000fff00000</span><span class="token punctuation">,</span><span class="token number">0x00000000fff00000</span><span class="token punctuation">,</span><span class="token number">0x00000000fff80000</span><span class="token punctuation">)</span>
 <span class="token class-name">ParOldGen</span>       total <span class="token number">7168</span>K<span class="token punctuation">,</span> used <span class="token number">0</span>K <span class="token punctuation">[</span><span class="token number">0x00000000ff600000</span><span class="token punctuation">,</span> <span class="token number">0x00000000ffd00000</span><span class="token punctuation">,</span> <span class="token number">0x00000000ffd00000</span><span class="token punctuation">)</span>
  object space <span class="token number">7168</span>K<span class="token punctuation">,</span> <span class="token number">0</span><span class="token operator">%</span> used <span class="token punctuation">[</span><span class="token number">0x00000000ff600000</span><span class="token punctuation">,</span><span class="token number">0x00000000ff600000</span><span class="token punctuation">,</span><span class="token number">0x00000000ffd00000</span><span class="token punctuation">)</span>
 <span class="token class-name">Metaspace</span>       used <span class="token number">3241</span>K<span class="token punctuation">,</span> capacity <span class="token number">4496</span>K<span class="token punctuation">,</span> committed <span class="token number">4864</span>K<span class="token punctuation">,</span> reserved <span class="token number">1056768</span>K
  <span class="token keyword">class</span> space    used <span class="token number">352</span>K<span class="token punctuation">,</span> capacity <span class="token number">388</span>K<span class="token punctuation">,</span> committed <span class="token number">512</span>K<span class="token punctuation">,</span> reserved <span class="token number">1048576</span>K
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于jdk7，对应元空间 PSPermGen：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code> <span class="token class-name">PSYoungGen</span>      total <span class="token number">3072</span>K<span class="token punctuation">,</span> used <span class="token number">1381</span>K <span class="token punctuation">[</span><span class="token number">0x00000000ffc80000</span><span class="token punctuation">,</span> <span class="token number">0x0000000100000000</span><span class="token punctuation">,</span> <span class="token number">0x0000000100000000</span><span class="token punctuation">)</span>
  eden space <span class="token number">2560</span>K<span class="token punctuation">,</span> <span class="token number">53</span><span class="token operator">%</span> used <span class="token punctuation">[</span><span class="token number">0x00000000ffc80000</span><span class="token punctuation">,</span><span class="token number">0x00000000ffdd9710</span><span class="token punctuation">,</span><span class="token number">0x00000000fff00000</span><span class="token punctuation">)</span>
  from space <span class="token number">512</span>K<span class="token punctuation">,</span> <span class="token number">0</span><span class="token operator">%</span> used <span class="token punctuation">[</span><span class="token number">0x00000000fff80000</span><span class="token punctuation">,</span><span class="token number">0x00000000fff80000</span><span class="token punctuation">,</span><span class="token number">0x0000000100000000</span><span class="token punctuation">)</span>
  <span class="token keyword">to</span>   <span class="token namespace">space</span> <span class="token number">512</span>K<span class="token punctuation">,</span> <span class="token number">0</span><span class="token operator">%</span> used <span class="token punctuation">[</span><span class="token number">0x00000000fff00000</span><span class="token punctuation">,</span><span class="token number">0x00000000fff00000</span><span class="token punctuation">,</span><span class="token number">0x00000000fff80000</span><span class="token punctuation">)</span>
 <span class="token class-name">ParOldGen</span>       total <span class="token number">7168</span>K<span class="token punctuation">,</span> used <span class="token number">0</span>K <span class="token punctuation">[</span><span class="token number">0x00000000ff580000</span><span class="token punctuation">,</span> <span class="token number">0x00000000ffc80000</span><span class="token punctuation">,</span> <span class="token number">0x00000000ffc80000</span><span class="token punctuation">)</span>
  object space <span class="token number">7168</span>K<span class="token punctuation">,</span> <span class="token number">0</span><span class="token operator">%</span> used <span class="token punctuation">[</span><span class="token number">0x00000000ff580000</span><span class="token punctuation">,</span><span class="token number">0x00000000ff580000</span><span class="token punctuation">,</span><span class="token number">0x00000000ffc80000</span><span class="token punctuation">)</span>
 <span class="token class-name">PSPermGen</span>       total <span class="token number">21504</span>K<span class="token punctuation">,</span> used <span class="token number">2905</span>K <span class="token punctuation">[</span><span class="token number">0x00000000fa380000</span><span class="token punctuation">,</span> <span class="token number">0x00000000fb880000</span><span class="token punctuation">,</span> <span class="token number">0x00000000ff580000</span><span class="token punctuation">)</span>
  object space <span class="token number">21504</span>K<span class="token punctuation">,</span> <span class="token number">13</span><span class="token operator">%</span> used <span class="token punctuation">[</span><span class="token number">0x00000000fa380000</span><span class="token punctuation">,</span><span class="token number">0x00000000fa656538</span><span class="token punctuation">,</span><span class="token number">0x00000000fb880000</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="设置堆内存的大小与oom" tabindex="-1"><a class="header-anchor" href="#设置堆内存的大小与oom" aria-hidden="true">#</a> 设置堆内存的大小与OOM</h3><p>Java堆区用于存储Java对象实例，那么堆的大小在 JVM 启动时就已经设定好了，可以通过选项 &quot;-Xmx&quot; 和 &quot;-Xms&quot; 来进行设置。</p><ul><li><p>&quot;-Xms&quot;用于表示堆区的起始内存**（memory start）**，等价于 -XX: InitialHeapSize</p></li><li><p>&quot;-Xmx&quot;则用于表示堆区的最大内存，等价于：-XX :MaxHeapSize</p></li></ul><p>一旦堆区中的内存大小超过 &quot;-Xmx&quot; 所指定的最大内存时，将会抛出 OutOfMemoryError 异常。</p><p><strong>通常会将 -Xms 和 -Xmx 两个参数配置相同的值，其目的是为了能够在 java 垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能。</strong>（比如不断扩容和缩容，造成系统压力）</p><p>默认情况下，<strong>初始内存大小：物理电脑内存大小/ 64，最大内存大小：物理电脑内存大小/ 4</strong></p><p><strong>Runtime实例：单例（运行时数据区）</strong></p><p>参数设置网址查看：</p><p><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html" target="_blank" rel="noopener noreferrer">https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><p>程序默认堆内存大小：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token doc-comment comment">/**
 * 设置堆空间大小的参数
 *      -Xms 设置堆空间（新生代+老年代）的初始内存大小
 *      -X：JVM运行参数
 *      ms：memory start
 * -Xmx：用来设置堆空间（新生代+老年代）的最大内存大小
 *
 * 默认内存大小：
 *      默认情况下，初始内存大小：物理电脑内存大小/ 64
 *      最大内存大小：物理电脑内存大小/ 4
 * 通常会将-Xms和-Xmx两个参数配置相同的值
 *      其目的是为了能够在java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能。
 *  查看设置的参数：
 *      方式一：jps     jstat -gc pid
 *      方式二：-XX:+PrintGCDetails
 * 修改堆内存空间大小：
 *  -Xms600m -Xmx600m
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HeapSpaceInitial</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 返回Java虚拟机中的堆内存总量</span>
        <span class="token keyword">long</span> initialMemory <span class="token operator">=</span> <span class="token class-name">Runtime</span><span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">totalMemory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">1024</span> <span class="token operator">/</span> <span class="token number">1024</span><span class="token punctuation">;</span>
        <span class="token comment">// 返回Java虚拟机试图使用的最大堆内存量</span>
        <span class="token keyword">long</span> maxMemory <span class="token operator">=</span> <span class="token class-name">Runtime</span><span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">maxMemory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">1024</span> <span class="token operator">/</span> <span class="token number">1024</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;initialMemory: &quot;</span> <span class="token operator">+</span> initialMemory<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//575</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;maxMemory &quot;</span> <span class="token operator">+</span> maxMemory<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//575</span>

        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;系统内存大小：&quot;</span> <span class="token operator">+</span> initialMemory <span class="token operator">*</span> <span class="token number">64</span> <span class="token operator">/</span> <span class="token number">1024</span> <span class="token operator">+</span> <span class="token string">&quot;G&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//7G    操作系统会占用一些内存</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;系统内存大小：&quot;</span> <span class="token operator">+</span> maxMemory <span class="token operator">*</span> <span class="token number">4</span> <span class="token operator">/</span> <span class="token number">1024</span> <span class="token operator">+</span> <span class="token string">&quot;G&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 配合jstat -gc pid</span>
        <span class="token comment">// 程序运行完成以后，-XX:+PrintGCDetails才会生效</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>查看设置的参数：</p><p>方式一：使用 jps + jstat 查看</p><p>jps：查看程序运行的进程</p><p>jstat -gc 9581：查看进程id为 9581的内存使用情况</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">D</span><span class="token operator">:</span>\<span class="token class-name">Software</span>\<span class="token class-name">Java</span>\jdk1<span class="token punctuation">.</span><span class="token number">8.0_181</span>\bin<span class="token operator">&gt;</span>jps
<span class="token number">18440</span> <span class="token class-name">Jps</span>
<span class="token number">15388</span> <span class="token class-name">HeapSpaceInitial</span>
<span class="token number">18908</span> <span class="token class-name">Launcher</span>

<span class="token class-name">D</span><span class="token operator">:</span>\<span class="token class-name">Software</span>\<span class="token class-name">Java</span>\jdk1<span class="token punctuation">.</span><span class="token number">8.0_181</span>\bin<span class="token operator">&gt;</span>jstat <span class="token operator">-</span>gc <span class="token number">15388</span>
 <span class="token constant">S0C</span>    <span class="token constant">S1C</span>    <span class="token constant">S0U</span>    <span class="token constant">S1U</span>      <span class="token constant">EC</span>       <span class="token constant">EU</span>        <span class="token constant">OC</span>         <span class="token constant">OU</span>       <span class="token constant">MC</span>     <span class="token constant">MU</span>    <span class="token constant">CCSC</span>   <span class="token constant">CCSU</span>   <span class="token constant">YGC</span>     <span class="token constant">YGCT</span>    <span class="token constant">FGC</span>    <span class="token constant">FGCT</span>     <span class="token constant">GCT</span>
<span class="token number">25600.0</span> <span class="token number">25600.0</span>  <span class="token number">0.0</span>    <span class="token number">0.0</span>   <span class="token number">153600.0</span> <span class="token number">18432.1</span>   <span class="token number">409600.0</span>     <span class="token number">0.0</span>     <span class="token number">4480.0</span> <span class="token number">775.1</span>  <span class="token number">384.0</span>   <span class="token number">76.4</span>       <span class="token number">0</span>    <span class="token number">0.000</span>   <span class="token number">0</span>      <span class="token number">0.000</span>    <span class="token number">0.000</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>说明：虽然设置了 -Xms600m，但是打印结果为 575m，是因为S0 和 S1对于垃圾回收来说只能有一个存储数据。</strong></p><p>方式二：-XX:+PrintGCDetails</p><p>注意：程序运行完成以后，-XX:+PrintGCDetails才会生效</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Heap</span>
 <span class="token class-name">PSYoungGen</span>      total <span class="token number">179200</span>K<span class="token punctuation">,</span> used <span class="token number">24576</span>K <span class="token punctuation">[</span><span class="token number">0x00000000f3800000</span><span class="token punctuation">,</span> <span class="token number">0x0000000100000000</span><span class="token punctuation">,</span> <span class="token number">0x0000000100000000</span><span class="token punctuation">)</span>
  eden space <span class="token number">153600</span>K<span class="token punctuation">,</span> <span class="token number">16</span><span class="token operator">%</span> used <span class="token punctuation">[</span><span class="token number">0x00000000f3800000</span><span class="token punctuation">,</span><span class="token number">0x00000000f50000b8</span><span class="token punctuation">,</span><span class="token number">0x00000000fce00000</span><span class="token punctuation">)</span>
  from space <span class="token number">25600</span>K<span class="token punctuation">,</span> <span class="token number">0</span><span class="token operator">%</span> used <span class="token punctuation">[</span><span class="token number">0x00000000fe700000</span><span class="token punctuation">,</span><span class="token number">0x00000000fe700000</span><span class="token punctuation">,</span><span class="token number">0x0000000100000000</span><span class="token punctuation">)</span>
  <span class="token keyword">to</span>   <span class="token namespace">space</span> <span class="token number">25600</span>K<span class="token punctuation">,</span> <span class="token number">0</span><span class="token operator">%</span> used <span class="token punctuation">[</span><span class="token number">0x00000000fce00000</span><span class="token punctuation">,</span><span class="token number">0x00000000fce00000</span><span class="token punctuation">,</span><span class="token number">0x00000000fe700000</span><span class="token punctuation">)</span>
 <span class="token class-name">ParOldGen</span>       total <span class="token number">409600</span>K<span class="token punctuation">,</span> used <span class="token number">0</span>K <span class="token punctuation">[</span><span class="token number">0x00000000da800000</span><span class="token punctuation">,</span> <span class="token number">0x00000000f3800000</span><span class="token punctuation">,</span> <span class="token number">0x00000000f3800000</span><span class="token punctuation">)</span>
  object space <span class="token number">409600</span>K<span class="token punctuation">,</span> <span class="token number">0</span><span class="token operator">%</span> used <span class="token punctuation">[</span><span class="token number">0x00000000da800000</span><span class="token punctuation">,</span><span class="token number">0x00000000da800000</span><span class="token punctuation">,</span><span class="token number">0x00000000f3800000</span><span class="token punctuation">)</span>
 <span class="token class-name">Metaspace</span>       used <span class="token number">3751</span>K<span class="token punctuation">,</span> capacity <span class="token number">4536</span>K<span class="token punctuation">,</span> committed <span class="token number">4864</span>K<span class="token punctuation">,</span> reserved <span class="token number">1056768</span>K
  <span class="token keyword">class</span> space    used <span class="token number">412</span>K<span class="token punctuation">,</span> capacity <span class="token number">428</span>K<span class="token punctuation">,</span> committed <span class="token number">512</span>K<span class="token punctuation">,</span> reserved <span class="token number">1048576</span>K
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>OOM测试：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>
<span class="token doc-comment comment">/**
 * 测试OOM
 * -Xms200m -Xmx200m
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OOMTest</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">BigDecimal</span><span class="token punctuation">&gt;</span></span> pics <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            pics<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>pics<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="年轻代与老年代" tabindex="-1"><a class="header-anchor" href="#年轻代与老年代" aria-hidden="true">#</a> 年轻代与老年代</h3><p>存储在 JVM 中的 Java 对象可以被划分为两类：</p><ul><li><p>一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速。</p></li><li><p>另外一类对象的生命周期却非常长，在某些极端的情况下还能够与JVM的生命周期保持一致。（如连接池等）</p></li></ul><p>Java 堆区进一步细分的话，可以划分为年轻代（YoungGen）和老年代（oldGen）</p><p>其中年轻代又可以划分为 Eden 空间、Survivor 0 空间和 Survivor 1 空间 (有时也叫做 from 区、to 区)。</p><p>注意：永久代和元空间只是逻辑存储。只能保证一个 Survivor 有数据，另一个 Survivor 有一个是不放数据的。</p><figure><img src="/assets/年轻代与老年代-c1a0bacc.png" alt="年轻代与老年代.png" tabindex="0" loading="lazy"><figcaption>年轻代与老年代.png</figcaption></figure><p><strong>（1）调整新生代与老年代的占比：</strong></p><p>配置新生代与老年代在堆结构的占比。<strong>【一般不会进行修改，除非生命周期长的对象占比很大】</strong></p><p>默认 -XX:NewRatio=2，表示新生代占1，老年代占2，新生代占整个堆的1/3</p><p>可以修改 -XX:NewRatio=4，表示新生代占1，老年代占4，新生代占整个堆的1/5。</p><p>示例：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token doc-comment comment">/**
 * 设置新生代、老年代的占比
 * -XX:NewRation    设置新生代与老年代的比例，默认是2（1:2）
 * -XX:SurvivorRatio    设置新生代中 Eden 区与 Survivor 区的比例
 * -XX:-UseAdaptiveSizePolicy   关闭自适应德尔内存分配策略
 * -Xmn300m     设置新生代的空间的大小（一般不设置）
 * 修改参数：-Xms600m -Xmx600m -XX:NewRatio=4
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SurvivorTest</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;start&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>（2）查看新生代老年代的占比：</strong></p><ul><li>方式一：Visual GC查看</li></ul><figure><img src="/assets/新生代老年代默认占比-725038f9.png" alt="新生代老年代默认占比.png" tabindex="0" loading="lazy"><figcaption>新生代老年代默认占比.png</figcaption></figure><ul><li>方式二：jstat -gc pid</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>D:<span class="token punctuation">\</span>Software<span class="token punctuation">\</span>Java<span class="token punctuation">\</span>jdk1.8.0_181<span class="token punctuation">\</span>bin<span class="token operator">&gt;</span>jps
<span class="token number">4980</span> Jps
<span class="token number">10024</span> Launcher
<span class="token number">3112</span> SurvivorTest

D:<span class="token punctuation">\</span>Software<span class="token punctuation">\</span>Java<span class="token punctuation">\</span>jdk1.8.0_181<span class="token punctuation">\</span>bin<span class="token operator">&gt;</span>jstat <span class="token parameter variable">-gc</span> <span class="token number">3112</span>
 S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT
<span class="token number">25600.0</span> <span class="token number">25600.0</span>  <span class="token number">0.0</span>    <span class="token number">0.0</span>   <span class="token number">153600.0</span> <span class="token number">73728.8</span>   <span class="token number">409600.0</span>     <span class="token number">0.0</span>     <span class="token number">4480.0</span> <span class="token number">775.1</span>  <span class="token number">384.0</span>   <span class="token number">76.4</span>       <span class="token number">0</span>    <span class="token number">0.000</span>   <span class="token number">0</span>      <span class="token number">0.000</span>    <span class="token number">0.000</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>方式三：jinfo -flag NewRatio pid</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>D:<span class="token punctuation">\</span>Software<span class="token punctuation">\</span>Java<span class="token punctuation">\</span>jdk1.8.0_181<span class="token punctuation">\</span>bin<span class="token operator">&gt;</span>jinfo <span class="token parameter variable">-flag</span> NewRatio <span class="token number">3112</span>
<span class="token parameter variable">-XX:NewRatio</span><span class="token operator">=</span><span class="token number">2</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>（3）调整新生代中 Eden 和 Survivor 的占比</strong></p><ul><li><p>在HotSpot中，Eden空间和另外两个Survivor空间缺省所占的比例是 <strong>8:1:1</strong></p></li><li><p>开发人员可以通过选项 <strong>&quot;-XX:SurvivorRatio&quot;</strong> 调整这个空间比例。<strong>比如-XX:SurvivorRatio=8</strong></p></li><li><p>需要注意的是：几乎所有的Java对象都是在Eden区被new出来的。绝大部分的Java对象的销毁都在新生代进行了。IBM公司的专门研究表明，新生代中80%的对象都是 &quot;朝生夕死&quot; 的。</p></li><li><p>可以使用选项 &quot;-Xmn&quot; 设置新生代最大内存大小，这个参数一般使用默认值就可以。</p></li><li><p>运行程序，结果不是 8:1:1，而是 6:1:1</p><p>原因：<strong>-XX:SurvivorRatio</strong> 默认为8，单独使用初始时生效，但是由于 <strong>-XX:+UseAdaptiveSizePolicy</strong> 默认开启，后期会自动调节Survivor区的大小，取消自适应（-XX:-UseAdaptiveSizePolicy）即可使得 -XX:SurvivorRatio 生效！</p><p><strong>注意：必须强制指定 -XX:SurvivorRatio=8，否则即使设置 -XX:-UseAdaptiveSizePolicy 也不生效。</strong></p></li></ul><figure><img src="/assets/Eden与Survivor占比-b7245efb.png" alt="Eden与Survivor占比.png" tabindex="0" loading="lazy"><figcaption>Eden与Survivor占比.png</figcaption></figure><ul><li>使用【-Xmn300m】设置新生代内存大小：如果使用-Xmn300m和-XX:NewRatio=8,则以-Xmn300m为准</li></ul><p>（4）<strong>几点说明</strong></p><p><strong>关于AdaptiveSizePolicy(自适应大小策略) 的说明</strong></p><p>​ JDK 1.8 默认使用 UseParallelGC 垃圾回收器，该垃圾回收器默认启动了 AdaptiveSizePolicy，会根据GC的情况自动计算计算 Eden、From 和 To 区的大小；</p><p>参数配置：</p><p>​ 开启：-XX:+UseAdaptiveSizePolicy<br> ​ 关闭：-XX:-UseAdaptiveSizePolicy</p><p><strong><mark>注意事项：</mark></strong></p><ol><li><p>在 JDK 1.8 中，如果使用 CMS，无论 UseAdaptiveSizePolicy 如何设置，都会将 UseAdaptiveSizePolicy 设置为 false；不过不同版本的JDK存在差异；</p></li><li><p>UseAdaptiveSizePolicy不要和SurvivorRatio参数显示设置搭配使用，一起使用会导致参数失效；</p></li><li><p>由于AdaptiveSizePolicy会动态调整 Eden、Survivor 的大小，有些情况存在Survivor 被自动调为很小，比如十几MB甚至几MB的可能，这个时候YGC回收掉 Eden区后，还存活的对象进入Survivor 装不下，就会直接晋升到老年代，导致老年代占用空间逐渐增加，从而触发FULL GC，如果一次FULL GC的耗时很长（比如到达几百毫秒），那么在要求高响应的系统就是不可取的。</p></li></ol><h3 id="图像对象的分配过程" tabindex="-1"><a class="header-anchor" href="#图像对象的分配过程" aria-hidden="true">#</a> 图像对象的分配过程</h3><h4 id="对象分配过程概述" tabindex="-1"><a class="header-anchor" href="#对象分配过程概述" aria-hidden="true">#</a> 对象分配过程概述</h4><p>​ 为新对象分配内存是一件非常严谨和复杂的任务，JVM的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑GC执行完内存回收后是否会在内存空间中产生内存碎片。</p><p><strong>（1）分配图示：</strong></p><figure><img src="/assets/图解对象分配过程01-d9dc5e38.png" alt="图解对象分配过程01.png" tabindex="0" loading="lazy"><figcaption>图解对象分配过程01.png</figcaption></figure><p>​ 第一次创建的对象会放在Eden区，等 Eden 区满之后 YGC （Young GC）会回收垃圾对象，将非垃圾对象放在S0区，标记次数（年龄）为1。</p><figure><img src="/assets/图解对象分配过程02-0f247ace.png" alt="图解对象分配过程02.png" tabindex="0" loading="lazy"><figcaption>图解对象分配过程02.png</figcaption></figure><p>​ 第二次Eden区满之后，YGC会将Eden和From区进行垃圾回收，将非垃圾对象放在To区，标记次数（age）为2。</p><figure><img src="/assets/图解对象分配过程03-51611343.png" alt="图解对象分配过程03.png" tabindex="0" loading="lazy"><figcaption>图解对象分配过程03.png</figcaption></figure><p>​ 依次反复，当对象的标记次数达到阈值以后，就会放入老年代。</p><p><strong>（2）注意事项：</strong></p><ol><li><p>只有Eden满了之后才会触发垃圾回收，S0和S1不会触发GC机制。</p></li><li><p>不一定非要等到阈值才会放在老年代，Eden和Survivor也可以不达到阈值就放在老年代。</p></li><li><p>对幸存者s0,s1区的总结：复制之后有交换，谁空谁是 to 区。</p></li><li><p>关于垃圾回收：频繁在新生区收集，很少在养老区收集，几乎不在永久区 / 元空间收集。</p></li></ol><p><strong>（3）分配步骤：</strong></p><figure><img src="/assets/图解对象分配流程-b9c82ee6.png" alt="图解对象分配流程.png" tabindex="0" loading="lazy"><figcaption>图解对象分配流程.png</figcaption></figure><ul><li><p>new的对象先放伊甸园（Eden）区，此区有大小限制。</p></li><li><p>当伊甸园的空间填满时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收（MinorGC）。</p><ul><li><p>将伊甸园区中的不再被其他对象所引用的对象进行销毁，然后将伊甸园中的剩余对象移动到幸存者S0区。</p></li><li><p>期间经历触发多次垃圾回收，此时上次幸存下来的放到幸存者0区的，如果没有回收，就会放到幸存者1区，依次往复。</p></li><li><p>如果S0区放不下对象，则新加入的对象直接放入老年代。当S0或S1中的对象存活超过阈值（默认15次）时，也会晋升为老年代。</p></li><li><p>可以设置参数: -XX : MaxTenuringThreshold=&lt;N&gt;进行设置。</p></li></ul></li><li><p>Minor GC完成后，再加载新的对象放到伊甸园区，如果 Eden 放得下，则分配内存空间，放不下就会放入老年代i，如果老年代也放不下，接下来就会进行Full GC，Full GC 完成后，老年代依旧放不下，就会 OOM。</p></li></ul><p>程序示例：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token doc-comment comment">/**
 * 演示内存分配过程
 * -Xms600m  -Xmx600m
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HeapInstanceTest</span> <span class="token punctuation">{</span>
    <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> buffer <span class="token operator">=</span>  <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token operator">*</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// list一直未被回收</span>
        <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">HeapInstanceTest</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HeapInstanceTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">try</span><span class="token punctuation">{</span>
                <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>
                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>使用Visual GC演示内存分配过程：</strong></p><figure><img src="/assets/程序演示内存分配过程-58d08df9.png" alt="程序演示内存分配过程.png" tabindex="0" loading="lazy"><figcaption>程序演示内存分配过程.png</figcaption></figure><p><strong>使用内存分析工具 jprofiler查看内存分配情况：</strong></p><p>安装：下载 jprofiler程序，安装完成后，再在idea插件中安装，选择安装位置即可。</p><p>使用示例：</p><figure><img src="/assets/内存分析工具jprofiler使用示例-edcf9121.png" alt="内存分析工具jprofiler使用示例.png" tabindex="0" loading="lazy"><figcaption>内存分析工具jprofiler使用示例.png</figcaption></figure><p><strong>常用调优工具</strong></p><p><strong>调优：减少GC</strong></p><ul><li>JDK命令行</li><li>Eclipse:Memory Analyzer Tool</li><li>Jconsole</li><li>Visua1VM]</li><li>Jprofiler</li><li>Java Flight Recorder</li><li>GCViewer</li><li>GC Easy</li><li>Jprofiler的使用：下载Jprofiler，安装jprofiler插件</li></ul><h3 id="minor-gc、major-gc、full-gc" tabindex="-1"><a class="header-anchor" href="#minor-gc、major-gc、full-gc" aria-hidden="true">#</a> Minor GC、Major GC、Full GC</h3><h4 id="部分收集和整堆收集" tabindex="-1"><a class="header-anchor" href="#部分收集和整堆收集" aria-hidden="true">#</a> 部分收集和整堆收集</h4><p>​ JVM在进行GC时，并非每次都对上面三个内存(新生代、老年代；方法区)区域一起回收的，大部分时候回收的都是指新生代。针对HotSpot VM的实现，它里面的GC按照回收区域又分为两大种类型：一种是部分收集(Partial GC)，一种是整堆收集(Full GC)。</p><ul><li><p>部分收集：不是完整收集整个Java堆的垃圾收集。其中又分为：</p><ul><li><p>新生代收集(Minor GC / Young GC) ：只是新生代(Eden\S0,S1) 的垃圾收集。</p></li><li><p>老年代收集(Major GC / 0ld GC) ：只是老年代的垃圾收集。</p><p>​ 目前，只有CMS GC会有单独收集老年代的行为。</p><p>​ 注意，很多时候 Major GC 会和 Full GC 混淆使用，需要具体分辨是老年代回收还是整堆回收。</p></li><li><p>混合收集(Mixed GC)：收集整个新生代以及部分老年代的垃圾收集。</p><p>目前，只有G1 GC会有这种行为</p></li></ul></li><li><p>整堆收集(Full GC)：收集整个java堆和方法区的垃圾收集。</p></li></ul><p><strong><mark>调优：减少GC次数，GC频繁会阻断用户线程的执行。</mark></strong></p><h4 id="年轻代gc-minor-gc-触发机制" tabindex="-1"><a class="header-anchor" href="#年轻代gc-minor-gc-触发机制" aria-hidden="true">#</a> 年轻代GC(Minor GC) 触发机制</h4><ol><li><p>当年轻代空间不足时，就会触发 Minor GC，这里的年轻代满指的是 Eden 代满，Survivor 满不会引发 GC。(每次 Minor GC 会清理年轻代的内存。)</p></li><li><p>因为 Java 对象大多都具备朝生夕灭的特性，所以 Minor GC 非常频繁，一般回收速度也比较快。这一定义既清晰又易于理解。</p></li><li><p>Minor GC 会引发 STW， 暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行。</p></li></ol><h4 id="老年代gc-major-gc-fu11-gc-触发机制" tabindex="-1"><a class="header-anchor" href="#老年代gc-major-gc-fu11-gc-触发机制" aria-hidden="true">#</a> 老年代GC (Major GC/Fu11 GC) 触发机制</h4><ol><li><p>指发生在老年代的GC，对象从老年代消失时，我们说 &quot;Major GC&quot; 或 &quot;Full GC&quot; 发生了。</p></li><li><p>出现了 Major GC， 经常会伴随至少一次的 Minor GC (但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程)。</p></li><li><p>也就是在老年代空间不足时，会先尝试触发 Minor GC。如果之后空间还不足，则触发 Major GC。</p></li><li><p>Major GC 的速度一般会比 Minor GC 慢10倍以上，STW 的时间更长。</p></li><li><p>如果 Major GC 后，内存还不足，就报 OOM 了。</p></li></ol><h4 id="full-gc触发机制" tabindex="-1"><a class="header-anchor" href="#full-gc触发机制" aria-hidden="true">#</a> Full GC触发机制</h4><p>触发Full GC执行的情况有如下五种：</p><p>(1) 调用 System. gc() 时，系统建议执行 Full GC，但是不必然执行。</p><p>(2) 老年代空间不足</p><p>(3) 方法区空间不足</p><p>(4) 通过 Minor GC 后进入老年代的平均大小大于老年代的可用内存。</p><p>(5) 由 Eden 区、Survivors pacee (From Space) 区向 Survivor space1 (ToSpace) 区复制时，对象大小大于 To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小。</p><p>说明：full gc 是开发或调优中尽量要避免的。这样暂时时间会短一些。</p><h3 id="对象分配过程-tlab" tabindex="-1"><a class="header-anchor" href="#对象分配过程-tlab" aria-hidden="true">#</a> 对象分配过程：TLAB</h3><p><strong>TLAB（Thread Local Allocation Buffer）</strong></p><p>为什么会有 TLAB？</p><ul><li>堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据</li><li>由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的</li><li>为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度</li></ul><p>jRocket 没有永久代</p><h2 id="垃圾回收概述" tabindex="-1"><a class="header-anchor" href="#垃圾回收概述" aria-hidden="true">#</a> 垃圾回收概述</h2><h3 id="什么是垃圾" tabindex="-1"><a class="header-anchor" href="#什么是垃圾" aria-hidden="true">#</a> 什么是垃圾</h3><p>Java相比于C++，增加了内存动态分配以及垃圾回收机制。</p><p>垃圾收集，不是Java语言的伴生产物。早在1960年，第一门开始使用内存动态分配和垃圾收集技术的Lisp语言诞生。<br> 关于垃圾收集有三个经典问题：</p><ul><li>哪些内存需要回收?</li><li>什么时候回收?</li><li>如何回收？</li></ul><p>垃圾收集机制是 Java 的招牌能力，极大地提高了开发效率。如今，垃圾收集几乎成为现代语言的标配，即使经过如此长时间的发展，Java的垃圾收集机制仍然在不断的演进中，不同大小的设备、不同特征的应用场景，对垃圾收集提出了新的挑战。</p><p>什么是垃圾（Garbage）？</p><blockquote><p>垃圾是指在运行程序中没有任何指针指向的对象，这个对象就是需要被回收的垃圾。<br> 外文:An object is considered garbage when it can no longer be reached from any pointer in the runningprogram.<br> 如果不及时对内存中的垃圾进行清理，那么，这些垃圾对象所占的内存空间会一直保留到应用程序结束，被保留的空间无法被其他对象使用。甚至可能导致内存溢出。</p></blockquote><h3 id="为什么需要gc" tabindex="-1"><a class="header-anchor" href="#为什么需要gc" aria-hidden="true">#</a> 为什么需要GC</h3><ul><li>对于高级语言来说，一个基本认知是如果不进行垃圾回收，<mark>内存迟早都会被消耗完。</mark></li><li>除了释放没用的对象，垃圾回收也可以清除内存里的记录碎片。碎片整理将所占用的堆内存移到堆的一端，以便 <mark>JVM 将整理出的内存分配给新的对象。</mark></li><li>随着应用程序所应付的业务越来越庞大、复杂，用户越来越多，==没有 GC 就不能保证应用程序的正常进行。==而经常造成STW 的 GC 又跟不上实际的需求，所以才会不断地尝试对 GC 进行优化。</li></ul><h3 id="早期垃圾回收" tabindex="-1"><a class="header-anchor" href="#早期垃圾回收" aria-hidden="true">#</a> 早期垃圾回收</h3><ul><li>在早期的C/C++时代，垃圾回收基本上是手工进行的。开发人员可以使用 new 关键字进行内存申请，并使用 delete 关键字进行内存释放。比如以下代码：</li></ul><div class="language-C++ line-numbers-mode" data-ext="C++"><pre class="language-C++"><code>MibBridge *pBridge = new cmBaseGroupBridge ();
//如果注册失败，使用Delete释放该对象所占内存区域
if(pBridge-&gt;Register (kDestroy) != NO_ ERROR)
delete pBridge;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>这种方式可以灵活控制内存释放的时间，但是会给开发人员带来频繁申请和释放内存的管理负担。倘若有一处内存区间由于程序员编码的问题忘记被回收，那么就会产生<mark>内存泄漏</mark>，垃圾对象永远无法被清除，随着系统运行时间的不断增长，垃圾对象所耗内存可能持续上升，直到出现内存溢出并造成应用程序崩溃。</li></ul><p>在有了垃圾回收机制后，上述代码块极有可能变成这样：</p><div class="language-C++ line-numbers-mode" data-ext="C++"><pre class="language-C++"><code>MibBridge *pBridge = new cmBaseGroupBridge ();
pBridge-&gt;Register (kDestroy);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>现在，除了Java以外，C#、Python、Ruby等语言都使用了自动垃圾回收的思想，也是未来发展趋势。可以说，这种自动化的内存分配和垃圾回收的方式己经成为现代开发语言必备的标准。</li></ul><h3 id="java-自动内存管理介绍" tabindex="-1"><a class="header-anchor" href="#java-自动内存管理介绍" aria-hidden="true">#</a> Java 自动内存管理介绍</h3><p>优点：</p><ul><li>自动内存管理，无需开发人员手动参与内存的分配与回收，这样降低内存泄漏和内存溢出的风险。</li><li>没有垃圾回收器，java也会和cpp一样，各种悬垂指针，野指针，泄露问题。</li><li>自动内存管理机制，将程序员从繁重的内存管理中释放出来，可以更专心地专注于业务开发</li><li>oracle官网关于垃圾回收的介绍：<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc.html" target="_blank" rel="noopener noreferrer">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc.html<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li></ul><p>缺点：</p><ul><li>对于Java开发人员而言，自动内存管理就像是一个黑匣子，如果过度依赖于“自动”，那么这将会是一场灾难，最严重的就会弱化Java开发人员在程序出现内存溢出时定位问题和解决问题的能力。</li><li>此时，了解 JVM 的自动内存分配和内存回收原理就显得非常重要，只有在真正了解 JVM 是如何管理内存后，我们才能够在遇见 outofMemoryError时，快速地根据错误异常日志定位问题和解决问题。</li><li>当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就必须对这些“自动化”的技术实施必要的监控和调节。</li></ul><h2 id="垃圾回收算法" tabindex="-1"><a class="header-anchor" href="#垃圾回收算法" aria-hidden="true">#</a> 垃圾回收算法</h2><h3 id="标记阶段-引用计数算法" tabindex="-1"><a class="header-anchor" href="#标记阶段-引用计数算法" aria-hidden="true">#</a> 标记阶段：引用计数算法</h3><h4 id="对象存活判断" tabindex="-1"><a class="header-anchor" href="#对象存活判断" aria-hidden="true">#</a> 对象存活判断</h4><p>在堆里存放着几乎所有的 Java 对象实例，在 GC 执行垃圾回收之前，首先需要区分出内存中哪些是存活对象，哪些是已经死亡的对象。只有被标记为己经死亡的对象，GC 才会在执行垃圾回收时，释放掉其所占用的内存空间，因此这个过程我们可以称为垃圾标记阶段。<br> 那么在 JVM 中究竟是如何标记一个死亡对象呢？<mark>简单来说，当一个对象已经不再被任何的存活对象继续引用时，就可以宣判为已经死亡。</mark><br> 判断对象存活一般有两种方式：<strong>引用计数算法和可达性分析算法。</strong></p><h4 id="引用计数算法的原理与优缺点" tabindex="-1"><a class="header-anchor" href="#引用计数算法的原理与优缺点" aria-hidden="true">#</a> 引用计数算法的原理与优缺点</h4><p>引用计数算法（Reference Counting）比较简单，对每个对象保存一个整型的引用计数器属性。用于记录对象被引用的情况。<br> 对于一个对象 A，只要有任何一个对象引用了 A，则 A 的引用计数器就加 1；当引用失效时，引用计数器就减 1。只要对象 A 的引用计数器的值为 0，即表示对象 A 不可能再被使用，可进行回收。<br> 优点：实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性。<br> 缺点：</p><ul><li><p>它需要单独的字段存储计数器，这样的做法增加了存储空间的开销。</p></li><li><p>每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了时间开销。</p></li><li><p>引用计数器有一个严重的问题，即无法处理循环引用的情况。这是一条致命缺陷，导致在Java的垃圾回收器中没有使用这类算法。</p><figure><img src="/assets/引用计数算法-循环引用问题-2b3dae32.png" alt="引用计数算法-循环引用问题.png" tabindex="0" loading="lazy"><figcaption>引用计数算法-循环引用问题.png</figcaption></figure></li></ul><p>Java 没有使用引用计数算法示例：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>
<span class="token doc-comment comment">/**
 * Java没有使用引用计数法的验证：
 * 使用 -XX:+PrintGCDetails
 *
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RefCountGC</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bigSize <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">5</span> <span class="token operator">*</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token class-name">Object</span> reference <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">RefCountGC</span> refCountGC01 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RefCountGC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">RefCountGC</span> refCountGC02 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RefCountGC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        refCountGC01<span class="token punctuation">.</span>reference <span class="token operator">=</span> refCountGC02<span class="token punctuation">;</span>
        refCountGC02<span class="token punctuation">.</span>reference <span class="token operator">=</span> refCountGC01<span class="token punctuation">;</span>

        refCountGC01 <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

        refCountGC02 <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token comment">// 显式执行垃圾回收行为</span>
<span class="token comment">//        System.gc();</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>​ 在使用 System.gc(); 和不使用的两种情况下，内存占用的空间不同，因此没有使用引用计数，如果使用了引用计数，则内存不会被回收，因为 refCountGC01 和 refCountGC02 的 reference 相互引用。</p><p>总结：</p><blockquote><p>引用计数算法，是很多语言的资源回收选择，例如Python，它更是同时支持引用计数和垃圾收集机制。<br> 具体哪种最优是要看场景的，业界有大规模实践中仅保留引用计数机制，以提高吞吐量的尝试。<br> Java并没有选择引用计数，是因为其存在一个基本的难题，也就是很难处理循环引用关系。<br> Python如何解决循环引用?</p><ol><li><p>手动解除，在合适的时机，解除引用关系。</p></li><li><p>使用弱引用weakref， weakref是Python提供的标准库，旨在解决循环引用。</p></li></ol></blockquote><h3 id="标记阶段-可达性分析算法" tabindex="-1"><a class="header-anchor" href="#标记阶段-可达性分析算法" aria-hidden="true">#</a> 标记阶段：可达性分析算法</h3><p>可达性分析算法也称为 根搜索算法、可追踪性算法。</p><p>相对于引用计数算法而言，可达性分析算法不仅同样具备实现简单和执行高效等特点，更重要的是该算法可以有效地解决在引用计数算法中循环引用的问题，防止内存泄漏的发生。<br> 相较于引用计数算法，这里的可达性分析就是Java、C#选择的。这种类型的垃圾收集通常也叫作追踪性垃圾收集（Tracing Garbage Collection) 。</p><h4 id="gc-rosts" tabindex="-1"><a class="header-anchor" href="#gc-rosts" aria-hidden="true">#</a> GC ROSTS</h4><p>所谓&quot;GC Roots&quot;根集合就是一组必须活跃的引用。<br> 基本思路:<br> 可达性分析算法是以根对象集合(GC Roots)为起始点，按照从上至下<br> 的方式搜索被根对象集合所连接的目标对象是否可达。</p><p>使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间<br> 接连接着，搜索所走过的路径称为引用链(Reference Chain)<br> 如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记为垃圾对象。<br> 在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象。</p><p>在Java语言中，G Roots包括以下几类元素:·虚拟机栈中引用的对象</p><blockquote><p>比如:各个线程被调用的方法中使用到的参数、局部变量等。本地方法栈内JNI(通常说的本地方法)引用的对象<br> ·方法区中类静态属性引用的对象<br> 比如: Java类的引用类型静态变量.方法区中常量引用的对象<br> 比如:字符串常量池(Sstring Table）里的引用所有被同步锁synchronized持有的对象<br> Java虚拟机内部的引用。<br> 基本数据类型对应的Class对象，一些常驻的异常对象（如:<br> NullPointerException、OutOfMemoryError），系统类加载器。<br> ·反映iava虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。</p></blockquote><p>除了这些固定的GC Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整GC Roots集合。比如：分代收集和局部回收(Partial GC）。</p><blockquote><p>如果只针对Java堆中的某一块区域进行垃圾回收（比如:典型的只针<br> 对新生代），必须考虑到内存区域是虚拟机自己的实现细节，更不是孤立封闭的，这个区域的对象完全有可能被其他区域的对象所引用，这时候就需要一并将关联的区域对象也加入GC Roots集合中去考虑，才能保证可达性分析的准确性。<br> .小技巧：<br> 由于Root采用栈方式存放变量和指针，所以如果一个指针，它保存了堆内存里面的对象，但是自己又不存放在堆内存里面，那它就是一个Root 。</p></blockquote><p>如果要使府可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能保障一致性的快照中进行。这点不满足的话分析结果的准确性就无法保证。<br> 这点也是导致Gc进行时必须 &quot;Stop The world&quot; 的一个重要原因。&gt;即使是号称（几乎）不会发生停顿的CMs 收集器中，枚举根节点时也是必须要停顿的。</p><h3 id="对象的-finalization-机制" tabindex="-1"><a class="header-anchor" href="#对象的-finalization-机制" aria-hidden="true">#</a> 对象的 finalization 机制</h3><ul><li>Java语言提供了对象终止（finalization）机制来允许开发人员提供对象被销毁之前的自定义处理逻辑。</li><li>当垃圾回收器发现没有引用指向一个对象，即：垃圾回收此对象之前，总会先调用这个对象的 finalize() 方法。</li><li>finalize () 方法允许在子类中被重写，用于在对象被回收时进行资源释放。<mark>通常在这个方法中进行一些资源释放和清理的工作，比如关闭文件、套接字和数据库连接等。</mark></li></ul><p><strong>注意事项：</strong></p><ol><li>永远不要主动调用某个对象的finalize()方法，应该交给垃圾回收机制调用。理由包括下面三点： <ul><li>在finalize ()时可能会导致对象复活。</li><li>finalize ()方法的执行时间是没有保障的，它完全由Gc线程决定，极端情况下，若不发生GC，则 finalize () 方法将没有执行机会。</li><li>一个糟糕的 finalize () 会严重影响 GC 的性能。</li></ul></li><li>从功能上来说，finalize ()方法与 C++ 中的析构函数比较相似，但是 Java采用的是基于垃圾回收器的自动内存管理机制，所以 finalize ()方法在本质上不同于 C++中的析构函数。</li><li>由于finalize ()方法的存在，虚拟机中的对象一般处于三种可能的状态。</li></ol><p>三种状态：</p><p>如果从所有的根节点都无法访问到某个对象，说明对象己经不再使用了。一般来说，此对象需要被回收。但事实上，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段。一个无法触及的对象有可能在某一个条件下“复活”自己，如果这样，那么对它的回收就是不合理的，为此，定义虚拟机中的对象可能的三种状态如下:</p><ul><li><p>可触及的：从根节点开始，可以到达这个对象。</p></li><li><p>可复活的：对象的所有引用都被释放，但是对象有可能在 finalize() 中复活。</p></li><li><p>不可触及的：对象的finalize () 被调用，并且没有复活，那么就会进入不可触及状态。不可触及的对象不可能被复活，因为 finalize() 只会被调用一次。</p><p>以上3种状态中，是由于finalize ()方法的存在，进行的区分。只有在对象不可触及时才可以被回收。</p></li></ul><p>具体过程：</p><p>判定一个对象objA是否可回收，至少要经历两次标记过程:，<br> 1.如果对象objA到GC Roots没有引用链，则进行第T次标记。<br> 2.进行筛选，判断此对象是否有必要执行finalize()方法<br> ①如果对象objA没有重 写finalize()方法，或者finalize ()方法已经被虚拟机调用过，<br> 则虚拟机视为“没有必要执行”，obj A被判定为不可触及的。<br> ②如果对象objA重写了 finalize()方法，且还未执行过，那么objA会被插入到F- Queue<br> 队列中，由一个虚拟机自动创建的、低优先级的F inalizer线程触发其finalize ()方<br> 法执行。<br> ③finalize() 方法是对象逃脱死亡的最后机会，稍后Gc会对F-Queue队列中的对象进行<br> 第二次标记。如果objA在finalize()方法中与引用链上的任何一个对象建立了联系，<br> 那么在第二次标记时，objA会被移出“即将回收”集合。之后，对象会再次出现没有引<br> 用存在的情况。在这个情况下，finalize方法不会被再次调用，对象会直接变成不可触<br> 及的状态，也就是说，一个对象的finalize方法只会被调用一次。</p><h3 id="mat-与-jprofiler-的-gc-rosts-溯源" tabindex="-1"><a class="header-anchor" href="#mat-与-jprofiler-的-gc-rosts-溯源" aria-hidden="true">#</a> MAT 与 jprofiler 的 GC ROSTS 溯源</h3><h3 id="清除阶段-标记-清除算法" tabindex="-1"><a class="header-anchor" href="#清除阶段-标记-清除算法" aria-hidden="true">#</a> 清除阶段：标记-清除算法</h3><h3 id="清除阶段-复制算法" tabindex="-1"><a class="header-anchor" href="#清除阶段-复制算法" aria-hidden="true">#</a> 清除阶段：复制算法</h3><h3 id="清除阶段-标记-压缩算法" tabindex="-1"><a class="header-anchor" href="#清除阶段-标记-压缩算法" aria-hidden="true">#</a> 清除阶段：标记-压缩算法</h3><h3 id="小结" tabindex="-1"><a class="header-anchor" href="#小结" aria-hidden="true">#</a> 小结</h3><h3 id="分代收集算法" tabindex="-1"><a class="header-anchor" href="#分代收集算法" aria-hidden="true">#</a> 分代收集算法</h3><h3 id="增量收集算法、分区算法" tabindex="-1"><a class="header-anchor" href="#增量收集算法、分区算法" aria-hidden="true">#</a> 增量收集算法、分区算法</h3><h2 id="垃圾回收概念" tabindex="-1"><a class="header-anchor" href="#垃圾回收概念" aria-hidden="true">#</a> 垃圾回收概念</h2><h2 id="垃圾回收器" tabindex="-1"><a class="header-anchor" href="#垃圾回收器" aria-hidden="true">#</a> 垃圾回收器</h2></div><!----><footer class="page-meta"><div class="meta-item edit-link"><a href="https://github.com/vuepress-theme-hope/vuepress-theme-hope/edit/main/src/Java/JVM.md" rel="noopener noreferrer" target="_blank" aria-label="编辑此页" class="nav-link label"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="edit icon"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></svg><!--]-->编辑此页<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="meta-item git-info"><!----><!----></div></footer><nav class="vp-page-nav"><a class="vp-link nav-link prev" href="/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html"><div class="hint"><span class="arrow start"></span>上一页</div><div class="link"><!---->设计模式</div></a><a class="vp-link nav-link next" href="/Java/Http.html"><div class="hint">下一页<span class="arrow end"></span></div><div class="link">Http<!----></div></a></nav><div id="comment" class="giscus-wrapper input-top" style="display:block;"><div class="loading-icon-wrapper" style="display:flex;align-items:center;justify-content:center;height:96px"><svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" preserveAspectRatio="xMidYMid" viewBox="25 25 50 50"><animateTransform attributeName="transform" type="rotate" dur="2s" keyTimes="0;1" repeatCount="indefinite" values="0;360"></animateTransform><circle cx="50" cy="50" r="20" fill="none" stroke="currentColor" stroke-width="4" stroke-linecap="round"><animate attributeName="stroke-dasharray" dur="1.5s" keyTimes="0;0.5;1" repeatCount="indefinite" values="1,200;90,200;1,200"></animate><animate attributeName="stroke-dashoffset" dur="1.5s" keyTimes="0;0.5;1" repeatCount="indefinite" values="0;-35px;-125px"></animate></circle></svg></div></div><!----><!--]--></main><!--]--><!----></div><!--]--><!----><!--]--></div>
    <script type="module" src="/assets/app-50124fd5.js" defer></script>
  </body>
</html>
