const e=JSON.parse('{"key":"v-1afa1ac7","path":"/Java/Effective%20Java.html","title":"EffectiveJava","lang":"en-US","frontmatter":{"title":"EffectiveJava","date":"2023-02-28T00:00:00.000Z","description":"Effective Java 用静态工厂方法代替构造器 遇到多个构造参数时考虑使用构建器 用私有构造器或枚举类型强化Singleton属性 通过私有构造器强化不可实例化的能力 优先考虑依赖注入来引用资源 避免创建不必要的对象 尽可能的重用单个对象，而不是每次需要的时候创建一个相同功能的新对象，如果对象是不可变的（immutable），那么它就始终可以被...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-MineTing.netlify.app/Java/Effective%20Java.html"}],["meta",{"property":"og:site_name","content":"Docs Demo"}],["meta",{"property":"og:title","content":"EffectiveJava"}],["meta",{"property":"og:description","content":"Effective Java 用静态工厂方法代替构造器 遇到多个构造参数时考虑使用构建器 用私有构造器或枚举类型强化Singleton属性 通过私有构造器强化不可实例化的能力 优先考虑依赖注入来引用资源 避免创建不必要的对象 尽可能的重用单个对象，而不是每次需要的时候创建一个相同功能的新对象，如果对象是不可变的（immutable），那么它就始终可以被..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"article:author","content":"MineTing"}],["meta",{"property":"article:published_time","content":"2023-02-28T00:00:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"EffectiveJava\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-02-28T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"MineTing\\"}]}"]]},"headers":[{"level":2,"title":"用静态工厂方法代替构造器","slug":"用静态工厂方法代替构造器","link":"#用静态工厂方法代替构造器","children":[]},{"level":2,"title":"遇到多个构造参数时考虑使用构建器","slug":"遇到多个构造参数时考虑使用构建器","link":"#遇到多个构造参数时考虑使用构建器","children":[]},{"level":2,"title":"用私有构造器或枚举类型强化Singleton属性","slug":"用私有构造器或枚举类型强化singleton属性","link":"#用私有构造器或枚举类型强化singleton属性","children":[]},{"level":2,"title":"通过私有构造器强化不可实例化的能力","slug":"通过私有构造器强化不可实例化的能力","link":"#通过私有构造器强化不可实例化的能力","children":[]},{"level":2,"title":"优先考虑依赖注入来引用资源","slug":"优先考虑依赖注入来引用资源","link":"#优先考虑依赖注入来引用资源","children":[]},{"level":2,"title":"避免创建不必要的对象","slug":"避免创建不必要的对象","link":"#避免创建不必要的对象","children":[]},{"level":2,"title":"消除过期的对象引用","slug":"消除过期的对象引用","link":"#消除过期的对象引用","children":[]},{"level":2,"title":"避免使用终结方法和清除方法","slug":"避免使用终结方法和清除方法","link":"#避免使用终结方法和清除方法","children":[]},{"level":2,"title":"try-with-resources 优先于 try-finally","slug":"try-with-resources-优先于-try-finally","link":"#try-with-resources-优先于-try-finally","children":[]},{"level":2,"title":"覆盖 equals 时请遵守通用约定","slug":"覆盖-equals-时请遵守通用约定","link":"#覆盖-equals-时请遵守通用约定","children":[]},{"level":2,"title":"覆盖 equals 时总要覆盖 hashCode","slug":"覆盖-equals-时总要覆盖-hashcode","link":"#覆盖-equals-时总要覆盖-hashcode","children":[]},{"level":2,"title":"始终覆盖 toString","slug":"始终覆盖-tostring","link":"#始终覆盖-tostring","children":[]},{"level":2,"title":"谨慎覆盖 clone","slug":"谨慎覆盖-clone","link":"#谨慎覆盖-clone","children":[]},{"level":2,"title":"考虑实现 Comparable 接口","slug":"考虑实现-comparable-接口","link":"#考虑实现-comparable-接口","children":[]}],"git":{},"readingTime":{"minutes":5.6,"words":1681},"filePathRelative":"Java/Effective Java.md","localizedDate":"February 28, 2023","autoDesc":true}');export{e as data};
