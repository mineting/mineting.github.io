import{_ as r}from"./plugin-vue_export-helper-c27b6911.js";import{r as h,o as i,c as t,b as e,e as d,w as o,f as n}from"./app-af68ac76.js";const s={},c={align:"center"},p=e("b",null,"CommonApplicationScenarios",-1),l=n('<h1 id="登录与单点登录" tabindex="-1"><a class="header-anchor" href="#登录与单点登录" aria-hidden="true">#</a> 登录与单点登录</h1><blockquote><p>包含以下内容：</p><ol><li>HTTP &amp; Cookie</li><li>单点登录简介</li><li>单点登录实现方式</li><li>单点登录协议</li><li>各个实现方式优缺点</li><li>现有的框架</li></ol></blockquote><h2 id="http-协议的无状态性" tabindex="-1"><a class="header-anchor" href="#http-协议的无状态性" aria-hidden="true">#</a> HTTP 协议的无状态性</h2><p>由于 Http 协议是无状态协议（无状态即服务器无法判断多次请求是否来自于同一个客户端，不能判断客户端的状态，服务器不会记录任何信息），一次请求一次响应，因此服务器不能区分用户，进而限制服务器对浏览器的响应，无法起到保护特定资源的作用。</p><p>对于以上问题，引入了会话机制，会话机制保证了一次临时的、交互式的信息（资源）交换，用户通过客户端与服务器之间的多次请求称为一次会话。</p><p>会话机制的实现有两种：客户端会话（Cookie）和服务端会话（Session），浏览器（客户端）发送请求时，可以携带 Cookie，Cookie 中存放一些信息，由浏览器和服务器共同维护一个相同的状态，判断是否为同一用户，这就使得 HTTP 不同的请求之间产生了关联。</p><p>单点登录（Single Sign On），简称为 SSO，是指在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。</p><p>客户端第一次给服务器发送请求，服务器获取不到 Session（HttpSession getSession()），就会创建新的，然后响应给浏览器，之后浏览器再次发送请求，通过 Cookie 将 session_id 附带给服务器，服务器通过对比 session_id 就能区分两次请求的客户端是否为同一个。</p><p>同一个客户端、同一个用户区分</p><h2 id="oauth2-0" tabindex="-1"><a class="header-anchor" href="#oauth2-0" aria-hidden="true">#</a> OAuth2.0</h2><p>OAuth2 是一种用于授权的开放标准，它允许授权服务（例如： Google，Facebook，Microsoft等）为第三方应用程序提供安全、受保护的资源访问。OAuth2通过客户端应用程序从资源所有者处请求访问权限，而不必请求资源所有者的登录凭据。OAuth2使用一系列标准化的授权流程，以确保第三方应用程序仅获得它们所需的访问权限。OAuth2标准已经成为Web应用程序和移动应用程序中最受欢迎的授权框架之一，广泛应用于今天的许多应用程序中。</p><p><strong>OAuth</strong>: An open protocol to allow secure authorization in a simple and standard method from web, mobile and desktop applications.</p><p>OAuth2流程</p><p>OAuth2是一种身份验证协议，用于授权第三方应用程序访问某个用户的资源。其流程如下：</p><p>用户向客户端发出资源请求。<br> 客户端将用户重定向到授权服务器，以获得认证许可。<br> 用户对授权请求进行身份验证，并授权客户端访问其资源。<br> 授权服务器将向客户端颁发访问令牌。<br> 客户端使用访问令牌向资源服务器请求访问被授权的资源。<br> 资源服务器确认访问令牌的有效性，并提供请求的资源。<br> 根据OAuth2协议的具体实现方式和需求，可能存在不同的身份验证方式和授权类型。例如，授权服务器可以使用密码授权类型（Resource Owner Password Credentials Grant）或客户端凭据授权类型（Client Credentials Grant）进行身份验证和授权，以授权更具体的权限。</p><p>举例说明OAuth2流程</p><p>假设用户使用Google账号登录某个第三方应用（例如Spotify），以下是OAuth2流程的可能实现方式：</p><p>用户在Spotify应用中点击“使用Google登录”按钮，向Spotify发送一个资源请求。<br> Spotify将用户重定向到Google认证服务器（授权服务器），以获得认证许可。<br> Google对认证请求进行身份验证，并提示用户进行权限授权（例如访问用户资料）。<br> 用户同意授权，Google将颁发访问令牌（Access Token）并重定向到Spotify。<br> Spotify使用刚才获得的访问令牌向Google请求用户资料和其他资源（例如Playlists）。<br> Google确认访问令牌的有效性，并提供请求的资源（例如用户资料）。<br> Spotify使用返回的资源构建用户界面，向用户显示其音乐播放列表。<br> 注意，这只是可能的 OAuth2 流程实现方式，实际的细节和行为取决于具体的身份验证方式、授权类型、应用程序设置和实现细节。</p><h2 id="混合移动" tabindex="-1"><a class="header-anchor" href="#混合移动" aria-hidden="true">#</a> 混合移动</h2><p>混合移动（Hybrid Mobile）是一种中间的移动应用开发方式，它是原生应用和Web应用之间的一种折中方案，结合了两者的特点。</p><p>混合移动应用是使用Web技术(HTML, CSS, JavaScript)编写的，类似于Web应用程序，但它可以打包成应用程序，通过应用商店直接发布到用户手机上，并通过桥接（Bridge）技术与设备本地功能进行交互。桥接技术是指将JavaScript代码封装成本地代码调用硬件或本机应用程序的能力，使得开发者可以调用设备上的功能，比如数据库，传感器和相机等。这也为开发人员提供了一些额外的优势，比如可以对设备进行更好的控制和访问。</p><p>相比原生应用，混合移动应用具有开发效率高、跨平台性强、维护成本低的优点。同时，它也比Web应用具有更好的性能、用户体验更好、可以获得更多的访问权限和能够在线上商店进行发布等优点。</p><p>总之，混合移动是一种中庸之道，同时具备Web应用程序和原生应用程序的优点，并可以有效提高应用程序开发效率和降低开发成本，是目前非常流行的移动应用程序开发方式之一。</p><h3 id="接入单点登录的步骤" tabindex="-1"><a class="header-anchor" href="#接入单点登录的步骤" aria-hidden="true">#</a> 接入单点登录的步骤</h3><p>接入单点登录的步骤大致如下：</p><p>选择合适的单点登录解决方案，比如OAuth2.0、SAML等，根据需求选择。</p><p>在你的应用程序中实现单点登录方案。这通常涉及到向用户提供一个“登录”按钮，然后将用户重定向到单点登录提供程序的登录页面。</p><p>用户在提供程序的登录页面中进行身份验证，并授权你的应用程序访问其数据。</p><p>提供程序令牌和同意授权将被返回到你的应用程序，对于OAuth2.0，这个令牌可以被用来访问许多不同的资源。</p><p>你的应用程序应该验证来自提供程序的令牌，以确保它们是有效的。验证的过程包括检查签名、令牌过期时间等。</p><p>登录成功后，你的应用程序应该创建你自己的会话，以维护用户的登录状态，并在用户访问其他受保护的页面时使用该会话来验证其登录状态。</p><p>这些步骤可以根据具体情况进行调整，但以上是单点登录的基本流程。</p><h2 id="协议" tabindex="-1"><a class="header-anchor" href="#协议" aria-hidden="true">#</a> 协议</h2><h2 id="实现方式" tabindex="-1"><a class="header-anchor" href="#实现方式" aria-hidden="true">#</a> 实现方式</h2><h2 id="代码实现" tabindex="-1"><a class="header-anchor" href="#代码实现" aria-hidden="true">#</a> 代码实现</h2><h1 id="日志" tabindex="-1"><a class="header-anchor" href="#日志" aria-hidden="true">#</a> 日志</h1><h1 id="跨域" tabindex="-1"><a class="header-anchor" href="#跨域" aria-hidden="true">#</a> 跨域</h1><h1 id="菜单、权限、字典、角色" tabindex="-1"><a class="header-anchor" href="#菜单、权限、字典、角色" aria-hidden="true">#</a> 菜单、权限、字典、角色</h1><h1 id="basecontroller-service-mapper-entity" tabindex="-1"><a class="header-anchor" href="#basecontroller-service-mapper-entity" aria-hidden="true">#</a> BaseController/Service/Mapper/Entity</h1><h1 id="vo-dto-pojo-entity-json" tabindex="-1"><a class="header-anchor" href="#vo-dto-pojo-entity-json" aria-hidden="true">#</a> VO/DTO/POJO/Entity/JSON</h1><h1 id="threadpoolexecutor" tabindex="-1"><a class="header-anchor" href="#threadpoolexecutor" aria-hidden="true">#</a> ThreadPoolExecutor</h1><h1 id="oss" tabindex="-1"><a class="header-anchor" href="#oss" aria-hidden="true">#</a> OSS</h1><h1 id="协议解析" tabindex="-1"><a class="header-anchor" href="#协议解析" aria-hidden="true">#</a> 协议解析</h1><h1 id="物联网" tabindex="-1"><a class="header-anchor" href="#物联网" aria-hidden="true">#</a> 物联网</h1><h1 id="常用表结构设计" tabindex="-1"><a class="header-anchor" href="#常用表结构设计" aria-hidden="true">#</a> 常用表结构设计</h1><h1 id="支付" tabindex="-1"><a class="header-anchor" href="#支付" aria-hidden="true">#</a> 支付</h1><h1 id="微信小程序" tabindex="-1"><a class="header-anchor" href="#微信小程序" aria-hidden="true">#</a> 微信小程序</h1><h1 id="httpclient" tabindex="-1"><a class="header-anchor" href="#httpclient" aria-hidden="true">#</a> HttpClient</h1><h1 id="表数据同步" tabindex="-1"><a class="header-anchor" href="#表数据同步" aria-hidden="true">#</a> 表数据同步</h1><h1 id="统一·日志-异常-结果" tabindex="-1"><a class="header-anchor" href="#统一·日志-异常-结果" aria-hidden="true">#</a> 统一·日志/异常/结果</h1><h1 id="gis" tabindex="-1"><a class="header-anchor" href="#gis" aria-hidden="true">#</a> GIS</h1><h1 id="批处理" tabindex="-1"><a class="header-anchor" href="#批处理" aria-hidden="true">#</a> 批处理</h1><h1 id="pdf" tabindex="-1"><a class="header-anchor" href="#pdf" aria-hidden="true">#</a> PDF</h1><h1 id="开源框架-ruoyi" tabindex="-1"><a class="header-anchor" href="#开源框架-ruoyi" aria-hidden="true">#</a> 开源框架 RuoYi</h1>',54);function u(b,f){const a=h("font");return i(),t("div",null,[e("div",c,[d(a,{size:"70"},{default:o(()=>[p]),_:1})]),l])}const S=r(s,[["render",u],["__file","常见场景实现.html.vue"]]);export{S as default};
